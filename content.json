[{"title":"CSS Sprite","date":"2018-07-17T09:03:16.426Z","path":"2018/07/17/CSS Sprite/","text":"简介css雪碧（精灵）是一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，利用css的背景定位来显示需要的部分，即background-position：x y； 原理把网站上需要用到的图片整合到一张单独的图片中，从而减少网站的http请求数量，其中，图片是在CSS中定义。 优点1. 减少加载网页图片时对服务器的请求次数 提高页面的加载速度 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!-- html实现--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;BOM&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;cat&quot;&gt; &lt;ul&gt; &lt;li class=&quot;cat-1&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;h3&gt;服饰内衣&lt;/h3&gt; &lt;/li&gt; &lt;li class=&quot;cat-2&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;h3&gt;鞋包配饰&lt;/h3&gt; &lt;/li&gt; &lt;li class=&quot;cat-3&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;h3&gt;运动户外&lt;/h3&gt; &lt;/li&gt; &lt;li class=&quot;cat-4&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;h3&gt;珠宝手表&lt;/h3&gt; &lt;/li&gt; &lt;li class=&quot;cat-5&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;h3&gt;手机数码&lt;/h3&gt; &lt;/li&gt; &lt;li class=&quot;cat-6&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;h3&gt;家电办公&lt;/h3&gt; &lt;/li&gt; &lt;li class=&quot;cat-7&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;h3&gt;护肤彩妆&lt;/h3&gt; &lt;/li&gt; &lt;li class=&quot;cat-8&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;h3&gt;母婴用品&lt;/h3&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!-- css实现--&gt; h3 ul&#123; margin: 0; padding: 0; &#125; h3&#123; display: block; margin: 0; padding: 0; &#125; .cat&#123; position: relative; width:150px; background:#f8f8f8; border:1px solid #bbb; &#125; ul&#123; list-style: none; &#125; li&#123; z-index: 2; position: relative; display: block; height:31px; line-height: 31px; overflow: hidden; //margin:1px 10px 0; vertical-align: bottom; border-bottom: 1px solid #dedede; &#125; li:hover&#123; background-color: #666666; &#125; li h3&#123; font-size: 14px; font-weight: 400; &#125; li i&#123; display: inline; float: left; margin: 3px 10px 0 0; height: 24px; width: 30px; &#125; li &gt; i&#123; background:url(&apos;http://img.mukewang.com/539a950e00015ba500710200.jpg&apos;); &#125; .cat-2 &gt; i&#123; background-position: 0 -24px; &#125; .cat-3 &gt; i&#123; background-position: 0 -48px; &#125; .cat-4 &gt; i&#123; background-position: 0 -72px; &#125; .cat-5 &gt; i&#123; background-position: 0 -96px; &#125; .cat-6 &gt; i&#123; background-position: 0 -120px; &#125; .cat-7 &gt; i&#123; background-position: 0 -144px; &#125; .cat-8 &gt; i&#123; background-position: 24px -168px; &#125;","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"构建es6环境","date":"2018-06-01T14:00:44.072Z","path":"2018/06/01/构建es6环境/","text":"项目目录创建1. 在es6项目问价下创建3个目录文件 app server tasks2. 在app下创建 css js views3. 在app/js下创建 index.js [入口文件] 创建class文件夹 &ensp;&ensp;&ensp;&ensp;app/class下创建test.js4. 在app/views下创建 error.ejs index.ejs [相当于html使用]5. 在es6目录下创建设置babel编译工具配置文件.babelrc6. 在es6下创建gulpfile.babel.js文件## 命令行处理、创建js编译任务1. 进入es6/server目录中 启动脚手架，表示启用ejs模板引擎 123express -e执行 npm install || cnpm install2. 在es6/tasks目录下创建util文件 在es6/tasks/util文件下创建args.js文件【注意】：在项目根目录中创建package.json依赖包文件（配置依赖），使用以下命令： 1npm init || cnpm init3. 编写args.js命令行处理文件 123456789101112131415161718192021222324252627282930313233import yargs from &apos;yargs&apos; //对参数进行操作 const args = yargs .option(&apos;production&apos;,&#123; boolean:true, default:false, //命令中没有production时，默认为开发环境，有就为线上环境 describe:&apos;min all script&apos; &#125;) //设置要不要自动编译 .option(&apos;watch&apos;,&#123; boolean:true, default:false, describe:&apos;watch all files&apos; &#125;) //设置是否需要输出编译日志 .option(&apos;verbose&apos;,&#123; boolean:true, default:false, describe:&apos;log&apos; &#125;) //处理压缩 .option(&apos;sourcemaps&apos;,&#123; describe:&apos;fource the creation of sourcemape&apos; &#125;) //设置服务器端口 .option(&apos;port&apos;,&#123; string:true, default:8080, describe:&apos;server port&apos; &#125;) .argv //以字符串形式解析 export default args;4. 在tasks目录下创建构建脚本script.js文件并编写script.js文件 ① 使用以下命令安装该代码中需要导入的依赖【注：后面不在重复展示安装依赖的过程】 12npm install gulp gulp-if gulp-concat webpack webpack-stream vinyl-named gulp-livereload gulp-plumber gulp-rename gulp-uglify gulp-util yargs --save-dev ② 编写scripts代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import gulp from &apos;gulp&apos;; //整个的构建都是基于gulpimport gulpif from &apos;gulp-if&apos;; //gulp语句中做if判断的import concat from &apos;gulp-concat&apos;; //gulp中处理文件拼接import webpack from &apos;webpack&apos;; //打包工具import gulpWebpack from &apos;webpack-stream&apos;;import named from &apos;vinyl-named&apos;; //做重命名标志的import livereload from &apos;gulp-livereload&apos;;//热中心，文件自动刷新import plumber from &apos;gulp-plumber&apos;;//处理文件信息流import rename from &apos;gulp-rename&apos;;//重命名import uglify from &apos;gulp-uglify&apos;;//处理压缩的import &#123;log,colors&#125; from &apos;gulp-util&apos;;//命令行输出的import args from &apos;./util/args&apos;;//利用gulp创建脚本任务gulp.task(&apos;scripts&apos;,() =&gt; &#123;return gulp.src([&apos;app/js/index.js&apos;]) //处理异常 .pipe(plumber(&#123; errorHandle:function()&#123; &#125; &#125;)) .pipe(named()) .pipe(gulpWebpack(&#123; module:&#123; loaders:[&#123; test:/|.js$/, loader:&apos;babel-loader&apos; &#125;] &#125; &#125;),null,(err,stats) =&gt; &#123; log(`Finished &apos;$&#123;colors,cyan(&quot;scripts&quot;)&#125;&apos;`,stats.toString(&#123; chunks:false &#125;)) &#125;) .pipe(gulp.dest(&apos;server/public/js&apos;)) // 必须uolify放到server上才额能运行 .pipe(rename(&#123; basename:&apos;cp&apos;, extname:&apos;.min.js&apos; &#125;)) //重命名 .pipe(uglify(&#123;compress:&#123;properties:false&#125;,output:&#123;&apos;quote_keys&apos;:true&#125;&#125;)) //压缩 .pipe(gulp.dest(&apos;server/public/js&apos;)) //监听文件，变化自动刷新 .pipe(gulpif(args.watch,livereload())) &#125;)5. 在tasks目录下创建处理模板的脚本page.js文件 1234567891011import gulp from &apos;gulp&apos;; //整个的构建都是基于gulpimport gulpif from &apos;gulp-if&apos;; //gulp语句中做if判断的import livereload from &apos;gulp-livereload&apos;;//热中心，文件自动刷新import args from &apos;./util/args&apos;;gulp.task(&apos;pages&apos;,() =&gt; &#123; return gulp.src(&apos;app/**/*.ejs&apos;) .pipe(gulp.dest(&apos;server&apos;)) .pipe(gulpif(args.watch,livereload())) //监听热更新&#125;)6. 在tasks目录下创建处理css的脚本css.js 12345678910import gulp from &apos;gulp&apos;; //整个的构建都是基于gulpimport gulpif from &apos;gulp-if&apos;; //gulp语句中做if判断的import livereload from &apos;gulp-livereload&apos;;//热中心，文件自动刷新import args from &apos;./util/args&apos;;gulp.task(&apos;css&apos;,() =&gt; &#123; //打开文件，并复制到server/public下，**表示全部的，*表示.css文件，包括嵌套文件 return gulp.src(&apos;app/**/*.css&apos;) .pipe(gulp.dest(&apos;server/public&apos;))&#125;)7. 在tasks目录下创建处理服务器的脚本server.js 12345678910111213141516171819202122232425262728import gulp from &apos;gulp&apos;; //整个的构建都是基于gulpimport gulpif from &apos;gulp-if&apos;; //gulp语句中做if判断的import liveserver from &apos;gulp-live-server&apos; //启动服务器的包import args from &apos;./util/args&apos;;//启动服务gulp.task(&apos;server&apos;,(cb) =&gt; &#123; //如果不在监听状态下，返回回调函数 if(!args.watch) return cb(); //在监听条件下，创建服务器 var server = liveserver.new([&apos;--harmony&apos;,&apos;server/bin/www&apos;]); server.start(); //启动服务器 //监听server目录下的js、ejs改变时热更新 gulp.watch([&apos;server/public/**/*.js&apos;,&apos;server/views/**/*.ejs&apos;],function(file)&#123; //通知服务器问价改变 server.notify.apply(server,[file]); &#125;) //监听需要重启服务的文件 gulp.watch([&apos;server/routes/**/*.js&apos;,&apos;server/app.js&apos;],function()&#123; //重启服务器 server.start.bind(server)(); //调用server的start的api &#125;); &#125;)8. 在tasks目录下创建default.js文件 12345import gulp from &apos;gulp&apos;; //整个的构建都是基于gulp //如果gulp执行答default就去找build.js文件gulp.task(&apos;default&apos;,[&apos;build&apos;]);9. 编写gulpfile.babel.js文件 123import requireDir from &apos;require-dir&apos;;requireDir(&apos;./tasks&apos;);10. 编写.babelrc文件【注：需要入住依赖babel-preset-es2015】 1234&#123; &quot;presets&quot;:[&quot;es2015&quot;]&#125;11. 运行gulp –watch 未报错，但是无法运行，运行命令结果如下图： 最终问题在server.js里面的一个重启服务的文件函数调错了，具体如下图：","tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"Ajax基础知识","date":"2018-03-16T13:41:10.721Z","path":"2018/03/16/ajax基础/","text":"Ajax简介 Ajax（Asynchronous JavaScript and XML）= 异步JavaScrip和XML,用于创建快速动态网页的技术，可以使网页实现异步更新，不用重新加载整个页面的情况下，对网页的局部更新。 Ajax基于现有的Internet标准，并且联合使用以下几种语言： ①：XMLHttpRequest对象(异步的与服务器交换数据) ②：JavaScript/DOM(信息显示/交互) ③：CSS(给数据定义样式) ④：XML(作为转换数据的格式) Ajax创建XMLHttp对象 创建XMLHttpRequest对象： 12variable = new XMLHttpRequest();variable = new ActiveObject(&quot;Microsoft.XMLHTTP&quot;); &lt;!--老版本的Intenet Explorer--&gt; 【注】首先检查是否存在“XMLHttpRequest”，代码如下： 12345if(window.XMLHttpRequest)&#123; xmlhttp = new XMLHttpRequest();&#125;else&#123; xmlhttp = new ActiveObject(&quot;Microsoft.XMLHTTP&quot;);&#125; 向服务器发送请求 XMLHttpRequest对象用于和服务器交换数据，所以如果需要请求发送到服务器，则使用该对象中的open()和send()方法。当open中第三个参数为false时，不可以编写onreadystatechange函数，只需要把代码放到send()语句后即可。若第三个参数为true，则需要规定在响应处于onreadystatechange事件中的就绪状态时执行函数， 123456789101112&lt;!-- 当第三个参数为true时执行onreadystatechange--&gt;xmlhttp.onreadystatechange=function()&#123; &lt;!--当readState等于4且状态为200时表示响应已经就绪--&gt; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; &#125;&#125;xmlhttp.open(&quot;GET&quot;,&quot;info.txt&quot;,true);&lt;!-- 第一个参数表示请求的类型，即GET或PSOT，第二个参数表示文件在服务器上的位置，第三个参数表示同步或一异步，即true表示异步，false表示同步--&gt;xmlhttp.send(); &lt;!-- 只使用post请求--&gt; 在open方法中，但使用GET方法请求时，读取的文件有可能是缓存中的结果，所以为了避免这种情况，一般会在URL上加一个唯一的ID，如果需要发送信息，也在URL上添加信息。当使用POST方法时，可用setRequestHeader()来添加HTTP头，然后在send方法中添加需要发送的数据。【注】在方法setRequestHeader(header，value)中有链各个参数，第一个是规定头的名称，第二个是规定头的值 Ajax服务器响应 XMLHttpRequest对象中的responseText 和responseXML 属性: ①：responseText：获得字符串形式的响应数据； ②：responseXML：获得XML形式的响应数据。 如果服务器的响应是 responseXML，则需要作为XML对象解析，如下代码： 12345678xmlDoc=xmlhttp.responseXML;txt=&quot;&quot;;x=xmlDoc.getElementsByTagName(&quot;ARTIST&quot;);for (i=0;i&lt;x.length;i++)&#123; txt=txt + x[i].childNodes[0].nodeValue + &quot;&lt;br&gt;&quot;;&#125;document.getElementById(&quot;myDiv&quot;).innerHTML=txt; onreadystatechange 事件 当请求被发送到服务器端的时候，需要执行一些基于响应的任务，每当readyState改变时，就会触发该事件，readyState属性存有XMLHttpRequest的状态信息。readyState状态从0到4的变化如下： ①：0：请求未初始化； ②：1：服务器连接已建立； ③：2：请求已接收; ④：3：请求处理中； ⑤：4：请求已完成，且响应已就绪。status的状态： ①：200：“ok”； ②：404：未找到页面。 基础知识铺垫 客户端与服务器概述 客户端主流操作系统：windows、mac、Linux 服务端操作系统：Linux、unix 客户端应用：qq、播放器、浏览器 服务端应用：网页服务（Apache、Nginx、tomcate（java）、iis（微软））、邮件服务（posfix）、文件上传下载服务（vsftp） 计算机通信协议 计算机组成： cpu（运算器和控制器）、存储器（硬盘、内存）、输入、输出设备 计算机运行机制：输入设备将数据发到cpu，cpu将数据传输到存储器（必须经过内存去访问硬盘），存储器传到输出设备（开机时所有数据会存储在存储器中）注意： 内存：程序一开始是在磁盘上，要想运行必须首先加载在内存 网络相关概念 IP地址：xxx.xxx.xxx.xxx 端口：用来区分电脑上的特定应用网络程序 域名：IP的别名（可以买卖） 域名和IP地址：对应关系不一定是一对一的 访问 http://www.baidu.com时： 1.域名解析 2.通过解析道德IP地址找到对应的计算机 DNS 配置网站服务器 前端和后端的角色分工 B/S:brower 浏览器，server 服务器 C/S：clienc 客户端（qq），server 服务器 如果一个功能有改进，所有使用的人都需要更新 同步和异步 同步：阻塞（白屏，整个页面刷新） 异步：（页面不全部刷新，局部刷新） 浏览网页的时候两种情况： 1.白屏（同步）； 2.页面不刷新（异步） 局部更新页面不会全屏刷新 实现异步局部更新（不使用XMLHttpRequest对象） 原生ajax实现异步通信","tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"计算机网络（物理层）","date":"2018-03-15T06:51:53.171Z","path":"2018/03/15/计算机网络(物理层)/","text":"物理层的主要任务描述为确定与传输媒体的接口有关的一些特性：(1) 物理特性；(2) 电气特性；(3) 功能特性；(4) 过程特性； 数据通信系统分为三部分：(1) 源系统（发送端，发送方）；(2) 传输系统(传输网络);(3) 目的系统(接收端，接收方) 常用术语：(1) 通信的目的是发送消息;(2) 数据是运送消息的实体;(3) 信号是数据的电气或电磁的表现; 信号分类：(1) 模拟信号(连续信号) — 代表消息的参数的取值是连续的；(2) 数字信号(离散信号) — 代表消息的参数的取值是离散的； 有关信道的几个基本概念(1) 通信的双方交互的方式：① 单向通信(单工通信)：只有一个方向的通信而没有反方向的交互；例 无线电/有限电视/电视广播 ② 双向交替通信(半双工通信):一方发送一方接收，过段时间在反过来，不可一起接收或发送； ③ 双向同时通信(全双工通信): 通信双方可同时发送和接收消息； 常见的编码方式：(1) 不归零制：正电平代表1，负电平代表0；(2) 归零制: 正脉冲代表1，负脉冲代表0；(3) 曼彻斯特编码：位周期中心的向上跳代表0，向下跳代表1，也可反过来定义；(4) 差分曼彻斯特编码：每一位的中心处始终都有跳变，位开始边界有跳变代表0，而位开始边界没有跳变代表1. 最基本的贷通调制方法：调幅，调频，调相； 传输媒体分为两大类：(1) 导引型传输媒体（双绞线、同轴电缆、光纤）；(2) 非导引型传输媒体（无线、红光、大气激光）； 常用的信道复用技术：频分复用、时分复用、统计时分复用、码分复用、波分复用。","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"计算机网络（数据链路层）","date":"2018-03-15T06:51:40.337Z","path":"2018/03/15/计算机网络（数据链路层）/","text":"链路： 一个结点到相邻结点的一段物理线路，也被称为物理链路； 数据链路：是物理链路加上一些必要的通信协议，也被称为逻辑链路； 梳理链路层的三个基本问题：(1) 封装成帧；(2) 透明传输；(3) 差错检测； 点对点协议（ppp）:(1) 组成：①：将ip数据报封装到串行链路的方法；&lt;br&gt; ②：用来建立、配置和测试链路连接的链路控制协议LCP；&lt;br&gt; ③：一套网络控制协议NCP; 共享信道技术： (1) 静态划分信道：用户只要分配到信道就不会和其他用户发生冲突。 (2) 动态媒体接入控制(多点接入):信道不在用户通信时固定分配，分配方式以下两种：①：随机接入：用户可随机发送信息，会产生碰撞（冲突），所以必须有解决碰撞（冲突）的网络协议；②：受控接入：用户不能随机的发送信息而必须服从一定的控制。 CSMA/CD协议要点： (1) 多点接入：计算机以多点接入的方式连接在一根总线上。协议的实质是“载波监听” 和 “碰撞检测”； (2) 载波监听：即检测信道，不管发送前还是发送中，每个站都必须不停的检测信道。 【注】工作过程：①:先听后发；②：边发边听；③：冲突回退；④：候时重发 使用网桥的优缺点： (1) 优点： ①：过滤通信量，增大吞吐量； ②：扩大了物理范围； ③：提高可靠性； ④：可互连不同物理层，不同MAC子层和不同速率。 (2) 缺点： ①：增加了时延； ②：在MAC子层没有流量控制功能； ③：网桥只适合用户数不多和通信量不太大的以太网，这就是所谓的广播风暴。 循环冗余检验CRC是一种检错方法，而帧检验序列FCS是添加在数据后面的冗余码。","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"计算机网络（网络层）","date":"2018-03-15T06:51:19.469Z","path":"2018/03/15/计算机网络（网络层）/","text":"网际协议IP是TCP/IP体系中最主要协议之一，以IP协议配套使用的三个协议：①：地址解析协议ARP;②：网际控制报文协议ICMP；③：网际组管理协议IGMP; 将网络互相连接起来的一些中间设备： ①：物理层使用的中间设备是转发器； ②：数据链路层使用的中间设备是网桥或桥接器； ③：网络层使用的中间设备叫做路由器； ④：在网络层以上使用的中间设备叫网关； IP地址由网络号和主机号构成，并且在整个因特网范围内是惟一的。 IP地址分类：（A,B,C类地址是单播地址，一对一通信，D类是多播地址，一对多通信，E类是保留） ①：A类：网络号：前8位，主机号后24位； ②：B类:网路号：前16位，主机号后16位； ③：C类：网络号:前24位，主机号后8位； IP的指派范围： ①：A类：1 - 126； ②：B类：128 - 191 ③：C类：192 - 223","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"计算机网络（运输层）","date":"2018-03-15T06:51:00.745Z","path":"2018/03/15/计算机网络（运输层）/","text":"网络层和运输层的区别：网络层是为主机智简提供逻辑通信，而运输层是为应用进程之间提供端到端的逻辑通信。 TCP/IP运输层的主要协议： ①：用户数据报协议UDP：不需要建立连接，不可靠交付，面向报文，没有拥塞控制，首部开销小。 ②：传输控制协议TCP:提供面向连接的服务，传输结束后要释放连接，可靠，面向连接的运输服务，每一条连接只有两个端点，全双工通信，面向字节流。 【注】常见的UDP应用： 应用&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;应用层协议 名字转换&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;DNS（域名系统） 文件传送&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;TFTP(简单文件传送协议) 路由选择协议&ensp;&ensp;&ensp;&ensp;RIP(路由信息协议) IP地址配置&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;DHCP(动态主机配置协议) 常见的TCP应用： 应用&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;应用层协议 电子邮件&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;SMTP(简单邮件传送协议) 远程终端接入件&ensp;&ensp;TELNET(远程终端协议) 万维网&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;HTTP(超文本传送协议) 文件传送&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;FTP(文件传送协议) TCP连接的端点叫做套接字（插口）， &ensp;&ensp;&ensp;&ensp;套接字socket=（IP地址：端口号） ==TCP连接的三次握手==： ①：客户端向服务器端发出连接请求，这时首部中的同步位SYN=1，选择一个初始序列号seq=x，此时不携带数据但要消耗序号，此时服务器进程进入SYN-SENT（同步已发送）状态 ②：服务器端收到请求，如果同意连接则向客户端发送确认信息，在此报文段中把SYN和ACK都置为1，确认号是ack=x+1，选择一个序列号seq=y，该报文段不携带数据，但要消耗序列号，此时服务器进程进入SYN-RCVD（同步收到）状态 ③：客户端收到服务器端的确认，确认报文段ACK=1，确认号ack=y+1，自己的序列号seq=x+1，此时ACK报文段携带数据，若不携带数据则不消耗序列号，此时TCP连接已经建立，客户端进入ESTABLISHED（已建立连接）状态 ==TCP连接释放过程的四次挥手==： ①：客户端首先向其TCP发出连接释放报文，并停止发送数据，主动关闭TCP连接，并把终止控制位FIN置位1，序号seq=u，等于前面已传送过的数据的最好一个字节的序号加1，此时客户端进入FIN-WAIT-1(终止等待1)状态，此时，FIN不携带数据但消耗序号。 ②：服务器端收到连接后即发出确认，确认号ack=u+1，该报文段自己的序号是v，然后服务器端进入CLOSE-WAIT(关闭等待)状态，此时客户端到服务器端的连接就释放了，此时TCP处于半关闭状态，即客户端不会再发送数据，但如果服务器端发送数据过来还是要接收。 ③：客户端收到服务器端的确认后，客户端就进入FIN-WAIT-2(终止等待2)状态，等待服务器端的连接释放报文。若服务器端已经没有要向客户端发送的数据了，其应用进程就通知TCP释放连接，此时服务器端发出的连接释放报文必须使FIN=1，假定服务器端的序号为w,服务器端还必须重复上次已发送过得确认号ack=u+1，此时服务器端进入LAST-ACK(最后确认)状态，等待客户端的确认。 ④：客户端收到服务器端的连接释放报文后，发出确认报文，在此报文中ACK置为1，确认号ack=w+1，自己的序列号seq=u+1，然后进入TIME-WAIT(时间等待)状态，此时TCP连接还没释放，必须经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSE状态，服务器端收到客户端发出的确认报文后就进入CLOSE状态，此时整个TCP连接就结束了。 在TCP释放连接的四次挥手中，服务器端的结束TCP连接时间比客户端要早，因为客户端在TIME-WAIT状态要等待2MSL的时间。 为什么客户端要在TIME-WAIT状态必须等待2MSL的时间？答：①：为了保证客户端发送的最后一个ACK报文段能够到达服务器端；②：防止“已失效的连接请求报文段”出现在本连接中。","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"计算机网络（一）","date":"2018-03-03T07:36:50.805Z","path":"2018/03/03/计算机网络(一)/","text":"交换方式： (1) 电路交换：必须的三个步骤—“创建连接-&gt;通话-&gt;释放连接”； 特点：在通话的全部时间内，通话的两个用户始终占用端到端的通信资源，并且线路的传输效率很低。 (2)分组交换：采用的死存储转发技术，一个分组包括一些必要的控制信息组成的首部和数据组成；分组在各路由器存储转发时需要排队，这会造成时延。【路由器是实现分组交换的关键构件】 (3)报文交换：整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。 通信方式： (1)客户-服务器方式（C/S方式）和对等方式（P2P方式） 计算机网络的种类 按作用范围分类： (1)广域网WAN (2)城域网MAN (3)局域网LAN (4)个人区域网PAN 按网络的使用者分类： (1)公用网 (2)专用网 计算机网络的性能指标 (1)速率：比特（bit）是及三级中数据量的单位，也是信息论中的信息量的单位；速率是指连接在计算机网络上的主机在数字信道上传送数据的速率； (2)带宽：本意指某个信号具有的频带宽度，即表示通信线路允许通过的信号频带范围。但是在计算机网络中，表示网络的通信线路传送数据的能力，即表示在的单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。 (3)吞吐量：表示在单位时间内通过某个网络（信道、接口）的数据量。 (4)时延：指数据从网络的一端传送到另一端所需的时间，分为以下几个部分：① 发送时延：主机或路由器发送数据帧所需要的时间，计算公式： 发送时延=数据帧长度(b) / 发送速率(b/s)【注：发送速率即带宽】。 ② 传播时延：电磁波在信道中传播一定的距离需要花费时间，公式如下： 传播时延=信道长度(m) / 电磁波在信道上的传播速率(m/s) ③ 处理时延 ④ 排队时延 总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延 (5)传播时延带宽积： 传播时延带宽积 = 传播时延 * 带宽 (6)往返时间RTT RTT = 中间结点的处理时延 + 排队时延 + 转发数据时发送时延 (7)利用率：信道或网络利用率过高会产生非常大的时延 网络协议：为进行网络中的数据交换而建立的规则、标准或约定，由以下3部分组成： (1) 语法：数据与控制信息的结构或格式 (2) 语义：需要发出何种控制信息，完成何种动作以及做出何种响应 (3) 同步：事件实现顺序的详细说明 协议的体系结构 (1)OSI的7层协议体系结构：①物理层；②数据链路层；③网络层(IP层)；④运输层；⑤会话层；⑥表示层；⑦应用层 (2)TCP/IP的体系结构：①网络接口层；②网际层IP；③运输层TCP/UDP；④应用层 (3)5层协议的体系结构：①物理层；②数据链路层；③网络层；④运输层；⑤应用层 运输层主要使用以下两种协议： (1)传输控制协议TCP — 提供面向连接的，可靠的数据传输协议，其数据传输的单位是报文段。 (2)用户数据报协议UDP — 提供无连接的，尽最大努力的数据传输服务（不可靠），数据传输单位是用户数据报。","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"初入Vue(一)","date":"2018-03-03T07:36:36.715Z","path":"2018/03/03/初入Vue(一)/","text":"接上一篇出现的问题，现在基本懂了，因为在vue2中对HTML和body标签做了限制，其具体源码如下：12345678910111.src/entries/web-runtime-with-compiler.jsel = el &amp;&amp; query(el) /* istanbul ignore if */ if (el === document.body || el === document.documentElement) &#123; process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn( `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.` ) return this &#125;","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"初入Vue","date":"2018-02-26T03:03:18.918Z","path":"2018/02/26/初入vue/","text":"&ensp;&ensp;&ensp;&ensp;刚开始接触vue，遇到一个不知道什么问题的问题，百度有人说是js的引入顺序问题，但是我是我引入顺序是正确的，还是没有得到答案。接下来说说问题：1234567891011121314151617181920212223242526272829303132&lt;script src=&quot;../vueBasic/vue.min.js&quot;&gt;&lt;/script&gt;&lt;body id=&quot;example&quot;&gt; &lt;ul &gt; &lt;li v-for=&quot;item in items&quot;&gt; &#123;&#123;item.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;script&gt;var demo = new Vue(&#123; el: &apos;#example&apos;, data: &#123; items: [ &#123; name:&apos;kuaiche&apos;, tag:1 &#125;, &#123; name:&apos;chuzuche&apos;, tag:3 &#125;, &#123; name:&apos;shunfengche&apos;, tag:2 &#125;, &#123; name:&apos;zhuangche&apos;, tag:0 &#125; ] &#125;&#125;)&lt;/script&gt; &ensp;&ensp;&ensp;&ensp;这是所有的代码，运行的时候会发现出现的结果并不是期待的列表顺序结果而是如图所示： &ensp;&ensp;&ensp;&ensp;学习vue遇到的第一个坑，目前找到的解决办法是在ul标签外面加一层div，并且设置id即可正常显示，但是现在我不知道为什么。等后面知道了原理再来解释。 修改后的html代码：1234567&lt;body&gt; &lt;div id=&quot;example&quot;&gt; &lt;ul &gt; &lt;li v-for=&quot;item in items&quot;&gt; &#123;&#123;item.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"块数据","date":"2018-02-06T02:25:30.251Z","path":"2018/02/06/代码重构/","text":"公务接待重构&ensp;&ensp;&ensp;&ensp;最近需求一直在改，每次都在原来的基础上加一些新的东西，但是到后来发现整个文件里面的代码特别乱，而且特别杂，注释也没有，有时候都不知道自己写的是什么功能，所以，决定把代码重构一波。 &ensp;&ensp;&ensp;&ensp;以前没有做过重构代码这种事情，这次是第一次，第一次重构代码给我的感觉就是，一边抱怨自己为什么当时不写个注释什么的，为什么不能再最开始写的时候多想想拓展性，另一边则一个一个方法的去看是什么功能，能不能把它写得更简单，能不能把里面的部分方法抽取出来，让整个文件的封装性更加的好。而且因为有些功能已经写了很久了，然后又没有加注释，所以有些状态的转化都已经忘记了，所以在我看来，重构代码真的不是痛苦的过程而是非常痛苦的过程。 &ensp;&ensp;&ensp;&ensp;我首先是重构的一个表单的提交页面，因为是手机端，所以需要注意的问题比pc端需要注意的问题更多。例如安卓和苹果的兼容性，而且在这个表单的提交页面上有很多的跨页面选择，填写数据，因此去处理跨页面保存数据也是一个问题，在这里，我使用的是==angular==的$rootScope来保存临时的数据，当需要的数据被保存以后，将$==rootScope==清空。整个过程让采用的是==ionic==加上angular，所以在使用ionic的插件的时候还得去考虑是否在苹果手机上展示的效果和需求要的效果是一样的。 &ensp;&ensp;&ensp;&ensp;值得庆幸的是这个过程中并没有遇到什么解决了很久都没有解决的问题。一般都是一点小小的问题，调试一下就可以搞定。 &ensp;&ensp;&ensp;&ensp;接下来说说后台的代码，因为我们用的是自己实验室封装的框架，所以很多的基础代码就直接通过创建实体的时候就已经生成好了，我要做的就是在已有的方法的基础上添加自己想要的方法，但是因为中间过程这一个文件有很多人在操作，每个人都写了一套自己的方法，导致整个后台的代码就显得特别的冗余，有很多可以共用的方法也没有被抽取出来。因为我是这一块的主要负责人，所以最后还是得我自己来把整个后台的代码也重新整理了一遍。 &ensp;&ensp;&ensp;&ensp;整个代码的重构过程花了大概5天的时间，当然，如果按完整的一天来算的话，大概也就2-3天的时间，只是这5天每天都有在做这个事情。现在基本完成了，回过头去看已经重构好的代码，没有了以前的冗余，加上了该有的注释，让整个代码都显得清晰明了，重构后的代码也将封装性，拓展性做的比之前更好一点。 通过这次重构代码的经历，也让我汲取了一些教训： 1. 写代码之前将需求搞清楚，思考清楚该怎么写，有没有效率更好的方法2. 每写一个方法或者一个不太清楚的变量都应该加上该有的注释，这样在以后别人看或者自己去看代码的时候才会知道这个方法是干什么的，不然可能就会变成，别人在看你代码的时候，一边看一边骂。3. 在一个就是封装性和拓展性以及兼容性，这三个部分是分厂重要的，做好了这3个部分可以减少很多的代码量，让整个代码看起来很清晰简洁。 第一次重构代码的一点感想，还是记录一下。","tags":[{"name":"代码重构","slug":"代码重构","permalink":"http://yoursite.com/tags/代码重构/"}]},{"title":"html5基础知识","date":"2018-01-24T02:12:58.062Z","path":"2018/01/24/html5基础知识/","text":"html5知识点总结 进度条：progress标签，如果要修改进度条样式，设置-webkit-apprearant：none。 多媒体的标签：audio:音频；vadio：视频。 新选择器（js里面的操作）：document.querySelector(‘.item’) —&gt; 返回dom对象；nt.querySelectorAll(‘.item’) —&gt; 返回元素类型是dom类型的数组.提示: $(‘.item’) —&gt; 返回一个jquery对象（实则是dom元素的数组，只是经过jquery封装） classList属性： eg:1234&lt;h1 class=&quot;class1 class2 class3&quot;&gt;&lt;/h1&gt;var h1 = document.getElementByTagName(&apos;h1&apos;)[0]var list = h1.classlist; 提示： 通过classList封装一些针对增加、删除、切换的方法，add(‘newClass’)、remove(‘oldClass’)、toggle(‘cl’)，存在的话就删除，不存在的话就添加 网页的离线访问—application cache 正常 应用程序缓存 html里面添加一个mainfest属性指向一个文件提示：文件：一般取名为cache.mainfest,在文件里面添加的内容为12345678910CACHE MANIFEST# version 1.0.1 CACHE: studyHtml5.html studyHtml5.js studyCss3.css NETWORK: * 注意：在cache：里面必须有一个tab键。 html各种标签属性及一些面试常问基础知识点 lang=’en,zh’：告诉搜索引擎爬虫，使其精确识别 ol标签上的常用属性：type、reversed、startwt ul标签上的常用属性:type 协议限定符： 1&lt;a href=&quot;javascript:&quot;&gt;email me&lt;/a&gt; 主流浏览器及其内核:ie（trident）、google（webkit/blink）、opera（presto）、safari（webkit）、firefox（gecko）。 css中各种类型的样式占的权重：！important — 正无穷、行间样式—1000、id选择器样式—100、class/属性/伪类选择器:10、通配符—0 样式垂直居中：用容器的height等于line-height 首行缩进：text-indent:2em；1em=16px=font-size（默认16px） 行级元素：span、strong、em、a、del 块级元素：div、p、ul、li、img、form、address 行级块元素：img 省略号：overflow:hidden;white-space:nowrap;text-overflow:ellipsis; 强制不换行：white-space:nowrap; 选择器：eg： 12345678910111213直接子元素选择器div &gt; em&#123;color:red;并列选择器div.demo .ttt&#123; background-color: red;&#125;分组选择器p, div, span&#123; background-color: red;&#125; js知识点总结 预编译过程 创建AO（执行期上下文）对象（全局的预编译生成GO对象） 将形参和变量名作为AO or GO的属性名，值为undefined 将实参的值和形参统一 在函数体里面找函数声明，值赋予函数体 作用域链（每一个函数定义的时候都会产生一个执行器上下文） eg 12345678910 a 被定义：创建a[[scope]] --&gt; GO a 被执行：将a的AO入栈到a[[scope]] function a()&#123;function b()&#123; var b = 123; &#125;var a = 234;b(); &#125; a();","tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"springIoc","date":"2017-11-28T09:34:02.825Z","path":"2017/11/28/springIOC/","text":"简易spring的IOC实现 &ensp;&ensp;&ensp;&ensp;首先需要理解一下什么叫做ioc（inversion of Controller），简单来说就是控制反转。它不是一门像js这样的技术，我们可以把它看做一种设计模式。为什么会出现IOC呢？&ensp;&ensp;&ensp;&ensp;传统的程序会导致类与类之间高耦合，难以测试，于是就把创建和查找依赖对象的控制权都交给一个容器，由容器来进行注入组合对象。这里可以把容器比作一个菜篮，以前没有菜篮的时候去买白菜的时候就特别不方便，后来有了篮子，不仅装东西方便，而且还送货上门，你只需要说一声，我需要白菜，直接送到家门口。spring就相当于这个篮子。它体现了一个法则：“不管怎样都不要来找我们，我们有需要的时候回来找你的”。接下来我就把一个简易的spring的IOC展示出来。 主要步骤 写一个IOC的类，用来解析配置文件，当然配置文件有很多种，但是这里我就用了一个xml的配置文件。这里面要用到反射的知识。 遍历xml文件中的所有的bean标签 获取bean标签里面的id和class属性，加载class对应的类，并创建bean 获取property标签的属性值，并填充到bean中 将bean注册到bean容器中 主要文件 首先有一个xml文件，我给它取名为springIoc 然后是读取xml文件的MySimpleIOC文件 然后有实体类，也就是model，我这里用了Student和studentClass 最后就是一个测试类（我用的是junit进行的测试） 关键代码展示[^code]&ensp;&ensp;&ensp;&ensp;这里主要是读取xml文件的整个过程，也是整个实现IOC的关键，至于其他的就不做过多的阐述 public MySimpleIOC(String location) throws Exception{ loadBeans(location); } private void loadBeans(String location) throws Exception { //加载xml配置文件 InputStream inputStream = new FileInputStream(location); DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder docBuilder = factory.newDocumentBuilder(); Document doc = docBuilder.parse(inputStream); Element root = doc.getDocumentElement(); NodeList nodes = ((Node) root).getChildNodes(); for(int i = 0;i &lt; nodes.getLength();i++){ Node node = (Node) nodes.item(i); if(node instanceof Element){ Element element = (Element) node; String id = element.getAttribute(&quot;id&quot;); String className = element.getAttribute(&quot;class&quot;); //加载beanClass Class beanClass = null; try{ beanClass = Class.forName(className); }catch(ClassNotFoundException e){ e.printStackTrace(); return; } //创建bean Object bean = beanClass.newInstance(); //遍历&lt;property&gt;标签 NodeList propertyNodes = element.getElementsByTagName(&quot;property&quot;); for(int j = 0;j &lt; propertyNodes.getLength();j++){ Node properNode = (Node) propertyNodes.item(j); if(properNode instanceof Element){ Element propertyElement = (Element) properNode; String name = propertyElement.getAttribute(&quot;name&quot;); String value = propertyElement.getAttribute(&quot;value&quot;); //利用反射将bean相关字段访问权限设为可访问 Field declaredField = bean.getClass().getDeclaredField(name); String tString = declaredField.getType().getName(); declaredField.setAccessible(true); if(value != null &amp;&amp; value.length() &gt; 0){ if(tString.equals(&quot;java.lang.Integer&quot;)){ Integer temp = Integer.parseInt(value); declaredField.set(bean, temp); }else{ //将属性填充到相关字段中 declaredField.set(bean, value); } }else{ String ref = propertyElement.getAttribute(&quot;ref&quot;); if(ref == null || ref.length() == 0){ throw new IllegalArgumentException(&quot;ref config error&quot;); } //将引用填充到相关字段中 declaredField.set(bean, getBean(ref)); } //将bean注册到bean容器中 registerBean(id,bean); } } } } } private void registerBean(String id, Object bean) { beanMap.put(id, bean); } public Object getBean(String name) { Object bean = beanMap.get(name); if(bean == null){ throw new IllegalArgumentException(&quot;there is no bean with name &quot; + name); } return bean; } &ensp;&ensp;&ensp;&ensp;刚刚说了关键就是上面那个步骤，下面我将测试类代码也展示一下。 @Test public void getBean() throws Exception{ String location = MySimpleIOC.class.getClassLoader().getResource(&quot;springIoc.xml&quot;).getFile(); String temp = location.substring(1, location.length()); MySimpleIOC ioc = new MySimpleIOC(temp); StudentClass studentClass = (StudentClass) ioc.getBean(&quot;studentClass&quot;); System.out.println(studentClass + &quot;,&quot; +studentClass.getCode() +&quot;,&quot;+ studentClass.getMark()); Student student = (Student) ioc.getBean(&quot;student&quot;); System.out.println(student+&quot;,&quot; +student.getName()+&quot;,&quot;+student.getStudentClass().getCode()); }","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"软件工程","date":"2017-11-28T09:34:02.818Z","path":"2017/11/28/softProject/","text":"第一章1.软件：程序+数据+文档；2.软件的特性：（1）复杂性；（2）一致性；（3）退化性；（4）易变性；（5）移植性；（6）高成本性；3.软件危机：（1）软件规模大，复杂度增加，需求量增加，价格昂贵，供需矛盾。（2）软件开发质量差，研制过程难管理。（3）开发模式不能适应软件发展的需求。4.解决软件危机（避免二次开发）：（1）需求分析；（2）做好软件定义时期工作；（3）开发过程要有统一的，公认的方法论和规范指导；（4）必须在测试阶段充分做好检测工作。5.软件工程：核心思想：强调开发过程中需要应用工程化思想。软件开发中工程化的主要思想：软件项目管理。软件项目管理的作用：（1）提高质量，降低成本；（2）为软件的工程化开发提供保障。6.能力成熟度模型：CMM；软件开发范式（模型）：主要区别：模型不同；7.软件工程基本原理：（1）推迟实现原理；（2）逐步求精原理；（3）分解与抽象原理；（4）信息隐蔽原理；（5）质量保证原理；8.基本原则（确保软件产品质量与开发效率）：（1）分阶段的软件生存周期；（2）坚持进行阶段评审；（3）实行严格的产品控制；（4）采用现代程序设计技术；（5）明确责任；（6）开发小组的人员应少而精；（7）不断改进开发过程；9.结构化开发范式：技术包括：结构化分析、结构化设计、结构化编程和结构化测试。10.面向对象开发范式：优势：维护阶段；11.重型软件工程和轻型软件工程：一般大型项目使用重型软件工程，小型项目使用轻型软件工程。12.软件工程活动：沟通活动（包括确认合适的用户，非正式沟通和正式沟通）、计划活动（项目计划 项目跟踪管理）、建模活动（软件建模分为软件过程建模和软件本身建模，建模活动包括构建模型，描述模型）、实现活动（编码）、部署活动（建立系统运行的环境）、维护活动（在软件运行和维护阶段对软件产品进行必要的调整和修改）、管理活动、过程改进活动（过程定义和过程改进）。","tags":[{"name":"shu","slug":"shu","permalink":"http://yoursite.com/tags/shu/"}]},{"title":"第一个md文件","date":"2017-11-28T09:34:02.811Z","path":"2017/11/28/helloworld/","text":"This is a h112var a = 0377;alert(a);","tags":[]},{"title":"Hello World","date":"2017-11-28T09:34:02.806Z","path":"2017/11/28/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]