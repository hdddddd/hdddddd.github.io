[{"title":"html5基础知识","date":"2018-01-24T02:12:58.062Z","path":"2018/01/24/html5基础知识/","text":"html5知识点总结 进度条：progress标签，如果要修改进度条样式，设置-webkit-apprearant：none。 多媒体的标签：audio:音频；vadio：视频。 新选择器（js里面的操作）：document.querySelector(‘.item’) —&gt; 返回dom对象；nt.querySelectorAll(‘.item’) —&gt; 返回元素类型是dom类型的数组.提示: $(‘.item’) —&gt; 返回一个jquery对象（实则是dom元素的数组，只是经过jquery封装） classList属性： eg: 1234&lt;h1 class=&quot;class1 class2 class3&quot;&gt;&lt;/h1&gt;var h1 = document.getElementByTagName(&apos;h1&apos;)[0]var list = h1.classlist; 提示： 通过classList封装一些针对增加、删除、切换的方法，add(‘newClass’)、remove(‘oldClass’)、toggle(‘cl’)，存在的话就删除，不存在的话就添加 网页的离线访问—application cache 正常 应用程序缓存 html里面添加一个mainfest属性指向一个文件提示：文件：一般取名为cache.mainfest,在文件里面添加的内容为12345678910CACHE MANIFEST# version 1.0.1 CACHE: studyHtml5.html studyHtml5.js studyCss3.css NETWORK: * 注意：在cache：里面必须有一个tab键。 html各种标签属性及一些面试常问基础知识点 lang=’en,zh’：告诉搜索引擎爬虫，使其精确识别 ol标签上的常用属性：type、reversed、startwt ul标签上的常用属性:type 协议限定符： 1&lt;a href=&quot;javascript:&quot;&gt;email me&lt;/a&gt; 主流浏览器及其内核:ie（trident）、google（webkit/blink）、opera（presto）、safari（webkit）、firefox（gecko）。 css中各种类型的样式占的权重：！important — 正无穷、行间样式—1000、id选择器样式—100、class/属性/伪类选择器:10、通配符—0 样式垂直居中：用容器的height等于line-height 首行缩进：text-indent:2em；1em=16px=font-size（默认16px） 行级元素：span、strong、em、a、del 块级元素：div、p、ul、li、img、form、address 行级块元素：img 省略号：overflow:hidden;white-space:nowrap;text-overflow:ellipsis; 强制不换行：white-space:nowrap; 选择器：eg： 12345678910111213直接子元素选择器div &gt; em&#123;color:red;并列选择器div.demo .ttt&#123; background-color: red;&#125;分组选择器p, div, span&#123; background-color: red;&#125; js知识点总结 预编译过程 创建AO（执行期上下文）对象（全局的预编译生成GO对象） 将形参和变量名作为AO or GO的属性名，值为undefined 将实参的值和形参统一 在函数体里面找函数声明，值赋予函数体 作用域链（每一个函数定义的时候都会产生一个执行器上下文） eg 12345678910 a 被定义：创建a[[scope]] --&gt; GO a 被执行：将a的AO入栈到a[[scope]] function a()&#123;function b()&#123; var b = 123; &#125;var a = 234;b(); &#125; a();","tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"ajax基础知识","date":"2018-01-24T02:10:41.886Z","path":"2018/01/24/ajax基础知识/","text":"ajax基础知识铺垫 客户端与服务器概述 客户端主流操作系统：windows、mac、Linux 服务端操作系统：Linux、unix 客户端应用：qq、播放器、浏览器 服务端应用：网页服务（Apache、Nginx、tomcate（java）、iis（微软））、邮件服务（posfix）、文件上传下载服务（vsftp） 计算机通信协议 计算机组成： cpu（运算器和控制器）、存储器（硬盘、内存）、输入、输出设备 计算机运行机制：输入设备将数据发到cpu，cpu将数据传输到存储器（必须经过内存去访问硬盘），存储器传到输出设备（开机时所有数据会存储在存储器中）注意： 内存：程序一开始是在磁盘上，要想运行必须首先加载在内存 网络相关概念 IP地址：xxx.xxx.xxx.xxx 端口：用来区分电脑上的特定应用网络程序 域名：IP的别名（可以买卖） 域名和IP地址：对应关系不一定是一对一的 访问 http://www.baidu.com时： 1.域名解析 2.通过解析道德IP地址找到对应的计算机 DNS 配置网站服务器 前端和后端的角色分工 B/S:brower 浏览器，server 服务器 C/S：clienc 客户端（qq），server 服务器 如果一个功能有改进，所有使用的人都需要更新 同步和异步 同步：阻塞（白屏，整个页面刷新） 异步：（页面不全部刷新，局部刷新） 浏览网页的时候两种情况： 1.白屏（同步）； 2.页面不刷新（异步） 局部更新页面不会全屏刷新 实现异步局部更新（不使用XMLHttpRequest对象） 原生ajax实现异步通信","tags":[{"name":"ajax","slug":"ajax","permalink":"http://yoursite.com/tags/ajax/"}]},{"title":"springIoc","date":"2017-11-28T09:34:02.825Z","path":"2017/11/28/springIOC/","text":"# 简易spring的IOC实现&ensp;&ensp;&ensp;&ensp;首先需要理解一下什么叫做ioc（inversion of Controller），简单来说就是控制反转。它不是一门像js这样的技术，我们可以把它看做一种设计模式。为什么会出现IOC呢？&ensp;&ensp;&ensp;&ensp;传统的程序会导致类与类之间高耦合，难以测试，于是就把创建和查找依赖对象的控制权都交给一个容器，由容器来进行注入组合对象。这里可以把容器比作一个菜篮，以前没有菜篮的时候去买白菜的时候就特别不方便，后来有了篮子，不仅装东西方便，而且还送货上门，你只需要说一声，我需要白菜，直接送到家门口。spring就相当于这个篮子。它体现了一个法则：“不管怎样都不要来找我们，我们有需要的时候回来找你的”。接下来我就把一个简易的spring的IOC展示出来。 主要步骤 写一个IOC的类，用来解析配置文件，当然配置文件有很多种，但是这里我就用了一个xml的配置文件。这里面要用到反射的知识。 遍历xml文件中的所有的bean标签 获取bean标签里面的id和class属性，加载class对应的类，并创建bean 获取property标签的属性值，并填充到bean中 将bean注册到bean容器中 主要文件 首先有一个xml文件，我给它取名为springIoc 然后是读取xml文件的MySimpleIOC文件 然后有实体类，也就是model，我这里用了Student和studentClass 最后就是一个测试类（我用的是junit进行的测试） 关键代码展示[^code]&ensp;&ensp;&ensp;&ensp;这里主要是读取xml文件的整个过程，也是整个实现IOC的关键，至于其他的就不做过多的阐述 public MySimpleIOC(String location) throws Exception{ loadBeans(location); } private void loadBeans(String location) throws Exception { //加载xml配置文件 InputStream inputStream = new FileInputStream(location); DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder docBuilder = factory.newDocumentBuilder(); Document doc = docBuilder.parse(inputStream); Element root = doc.getDocumentElement(); NodeList nodes = ((Node) root).getChildNodes(); for(int i = 0;i &lt; nodes.getLength();i++){ Node node = (Node) nodes.item(i); if(node instanceof Element){ Element element = (Element) node; String id = element.getAttribute(&quot;id&quot;); String className = element.getAttribute(&quot;class&quot;); //加载beanClass Class beanClass = null; try{ beanClass = Class.forName(className); }catch(ClassNotFoundException e){ e.printStackTrace(); return; } //创建bean Object bean = beanClass.newInstance(); //遍历&lt;property&gt;标签 NodeList propertyNodes = element.getElementsByTagName(&quot;property&quot;); for(int j = 0;j &lt; propertyNodes.getLength();j++){ Node properNode = (Node) propertyNodes.item(j); if(properNode instanceof Element){ Element propertyElement = (Element) properNode; String name = propertyElement.getAttribute(&quot;name&quot;); String value = propertyElement.getAttribute(&quot;value&quot;); //利用反射将bean相关字段访问权限设为可访问 Field declaredField = bean.getClass().getDeclaredField(name); String tString = declaredField.getType().getName(); declaredField.setAccessible(true); if(value != null &amp;&amp; value.length() &gt; 0){ if(tString.equals(&quot;java.lang.Integer&quot;)){ Integer temp = Integer.parseInt(value); declaredField.set(bean, temp); }else{ //将属性填充到相关字段中 declaredField.set(bean, value); } }else{ String ref = propertyElement.getAttribute(&quot;ref&quot;); if(ref == null || ref.length() == 0){ throw new IllegalArgumentException(&quot;ref config error&quot;); } //将引用填充到相关字段中 declaredField.set(bean, getBean(ref)); } //将bean注册到bean容器中 registerBean(id,bean); } } } } } private void registerBean(String id, Object bean) { beanMap.put(id, bean); } public Object getBean(String name) { Object bean = beanMap.get(name); if(bean == null){ throw new IllegalArgumentException(&quot;there is no bean with name &quot; + name); } return bean; } &ensp;&ensp;&ensp;&ensp;刚刚说了关键就是上面那个步骤，下面我将测试类代码也展示一下。 @Test public void getBean() throws Exception{ String location = MySimpleIOC.class.getClassLoader().getResource(&quot;springIoc.xml&quot;).getFile(); String temp = location.substring(1, location.length()); MySimpleIOC ioc = new MySimpleIOC(temp); StudentClass studentClass = (StudentClass) ioc.getBean(&quot;studentClass&quot;); System.out.println(studentClass + &quot;,&quot; +studentClass.getCode() +&quot;,&quot;+ studentClass.getMark()); Student student = (Student) ioc.getBean(&quot;student&quot;); System.out.println(student+&quot;,&quot; +student.getName()+&quot;,&quot;+student.getStudentClass().getCode()); }","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"软件工程","date":"2017-11-28T09:34:02.818Z","path":"2017/11/28/softProject/","text":"第一章1.软件：程序+数据+文档；2.软件的特性：（1）复杂性；（2）一致性；（3）退化性；（4）易变性；（5）移植性；（6）高成本性；3.软件危机：（1）软件规模大，复杂度增加，需求量增加，价格昂贵，供需矛盾。（2）软件开发质量差，研制过程难管理。（3）开发模式不能适应软件发展的需求。4.解决软件危机（避免二次开发）：（1）需求分析；（2）做好软件定义时期工作；（3）开发过程要有统一的，公认的方法论和规范指导；（4）必须在测试阶段充分做好检测工作。5.软件工程：核心思想：强调开发过程中需要应用工程化思想。软件开发中工程化的主要思想：软件项目管理。软件项目管理的作用：（1）提高质量，降低成本；（2）为软件的工程化开发提供保障。6.能力成熟度模型：CMM；软件开发范式（模型）：主要区别：模型不同；7.软件工程基本原理：（1）推迟实现原理；（2）逐步求精原理；（3）分解与抽象原理；（4）信息隐蔽原理；（5）质量保证原理；8.基本原则（确保软件产品质量与开发效率）：（1）分阶段的软件生存周期；（2）坚持进行阶段评审；（3）实行严格的产品控制；（4）采用现代程序设计技术；（5）明确责任；（6）开发小组的人员应少而精；（7）不断改进开发过程；9.结构化开发范式：技术包括：结构化分析、结构化设计、结构化编程和结构化测试。10.面向对象开发范式：优势：维护阶段；11.重型软件工程和轻型软件工程：一般大型项目使用重型软件工程，小型项目使用轻型软件工程。12.软件工程活动：沟通活动（包括确认合适的用户，非正式沟通和正式沟通）、计划活动（项目计划 项目跟踪管理）、建模活动（软件建模分为软件过程建模和软件本身建模，建模活动包括构建模型，描述模型）、实现活动（编码）、部署活动（建立系统运行的环境）、维护活动（在软件运行和维护阶段对软件产品进行必要的调整和修改）、管理活动、过程改进活动（过程定义和过程改进）。","tags":[{"name":"shu","slug":"shu","permalink":"http://yoursite.com/tags/shu/"}]},{"title":"第一个md文件","date":"2017-11-28T09:34:02.811Z","path":"2017/11/28/helloworld/","text":"This is a h112var a = 0377;alert(a);","tags":[]},{"title":"Hello World","date":"2017-11-28T09:34:02.806Z","path":"2017/11/28/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]