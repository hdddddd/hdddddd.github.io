[{"title":"纯前端导出Excel","date":"2019-01-08T08:31:45.657Z","path":"2019/01/08/纯前端导出Excel (1)/","text":"需求前提导师提出一个需求实现一个交叉表的展示。简单的说就是在一个excel表格中有一部分主要的列，还有一部分列是不确定的，可能只有一列，也可能有很多列，并且这些数据的样式是可以通过配置去渲染，因此对于这个样式以及数据等等都是动态的。当前台获取到后台的数据的时候，对该数据做了一些格式的转换，并且对表格的样式进行了渲染，所以，如果此时在把表格数据传回后台去做导出，不管是数据还是样式都不太方便，因此，提出了一个前端直接导出Excel的需求。 刚开始没有任何的头绪，后来在找资料的过程中发现了一个叫做js-xlsx的插件（插件的github地址），当然仅仅用这一个插件是不能实现导出的，它必须配合fileSaver才能实现导出，之前也提到说要对表格的样式进行相应的渲染，然而在js-xlsx的api中并没有给出相应的功能，因此，此时还需要用到一个插件叫做xlsx-style,通过这个插件可以给表格设置相应的样式，具体样式如下表所示： 样式属性 子属性 取值 fill patternType “solid” or “none” fgColor COLOR_SPEC bgColor COLOR_SPEC font name “Calibri” // default sz “11” // font size in points color COLOR_SPEC bold true or false underline true or false italic true or false strike true or false outline true or false shadow true or false vertAlign true or false numFmt “0” “0.00%” “0.0%” “0.00%;\\(0.00%\\);\\-;@” “m/dd/yy” alignment vertical “bottom” or “center” or “top” horizontal “bottom” or “center” or “top” wrapText true or false readingOrder 2 // for right-to-left textRotation Number from 0 to 180 or 255 (default is 0) 90 is rotated up 90 degrees 45 is rotated up 45 degrees 135 is rotated down 45 degrees 180 is rotated down 180 degrees 255 is special, aligned vertically border top { style: BORDER_STYLE, color: COLOR_SPEC } bottom { style: BORDER_STYLE, color: COLOR_SPEC } left { style: BORDER_STYLE, color: COLOR_SPEC } right { style: BORDER_STYLE, color: COLOR_SPEC } diagonal { style: BORDER_STYLE, color: COLOR_SPEC } diagonalUp true or false diagonalDown true or false 上表就是整个excel支持的全部样式。 操作步骤 首先我是基于vue去实现的，因此我首先是需要下载依赖，分别下载依赖是xlsx、fileSaver、xlsx-style。 在使用的地方导入相关依赖 123const XLSX = require(\"xlsx\");import FileSaver from \"file-saver\";const xlsxStyle =require(\"xlsx-style\"); 具体的实现 我在实现的过程中因为要对表格的样式进行渲染，因此我需要去做判断哪些需要渲染，这一块是稍微复杂一点的东西。具体的代码含义在代码注释里面也已写出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133 static downloadData(fileName,tableDatas,borderAll)&#123; let domTable = document.querySelector(\"#tableKey\"); //raw:true表示导出的数据全部以字符串形式展示，解决可能出现的格式是百分比，导出却是小数 let wb = XLSX.utils.table_to_book(domTable,&#123;raw:true&#125;); let wbSheet = wb.Sheets.Sheet1; //转化为ASC码的形式 let ascCol = ((wbSheet[\"!ref\"].split(\":\")[1].charAt(0)).charCodeAt() - 1); //得到最大的列 let maxCol = String.fromCharCode(ascCol); //设置每一个单元格的宽度 wbSheet['!cols'] = this.setCols(wbSheet,100,maxCol,tableDatas);; let count = 0; //对每个单元格的样式进行设置 for(let key in wb.Sheets.Sheet1)&#123; if((/[A-Z]/.test((key.charAt(0)))) &amp;&amp; (key.charAt(0)) &lt;= maxCol)&#123; wb.Sheets.Sheet1[key].s = &#123; border:borderAll, numFmt:'', alignment:&#123; horizontal: \"center\", vertical: \"center\" &#125;, font: &#123; name: '宋体', sz: 11, color: &#123;rgb: \"#FF000000\"&#125;, //bold: true, italic: false, underline: false &#125;, &#125; &#125; if((/[B-Z]/.test((key.charAt(0)))))&#123; if((key.charAt(0)) == maxCol)&#123; if(tableDatas[count] &amp;&amp; tableDatas[count].color)&#123; wb.Sheets.Sheet1[key].s = &#123; border:borderAll, numFmt:'', alignment:&#123; horizontal: \"center\", vertical: \"center\" &#125;, font: &#123; name: '宋体', sz: 11, color: &#123;rgb: \"#FF000000\"&#125;, //bold: true, italic: false, underline: false &#125;, fill:&#123; fgColor:&#123; rgb: tableDatas[count].color.split('#')[1] &#125; &#125; &#125; &#125; count = 0; &#125;else&#123; if(((key.charAt(0)).charCodeAt()) &lt;= ascCol)&#123; if(tableDatas[count] &amp;&amp; tableDatas[count].color)&#123; wb.Sheets.Sheet1[key].s = &#123; border:borderAll, numFmt:'', alignment:&#123; horizontal: \"center\", vertical: \"center\" &#125;, font: &#123; name: '宋体', sz: 11, color: &#123;rgb: \"#FF000000\"&#125;, //bold: true, italic: false, underline: false &#125;, fill:&#123; fgColor: &#123; rgb: tableDatas[count].color.split('#')[1] &#125; &#125; &#125; &#125; count++; &#125; &#125; &#125; &#125; //通过fileSaver导出Excel表格 let wbout = xlsxStyle.write(wb, &#123; bookType: 'xlsx', bookSST: true, type: 'buffer' &#125;); try&#123; FileSaver.saveAs(new Blob([wbout],&#123;type : 'application/octet-stream;charset=utf-8' &#125;), fileName + \".xlsx\"); &#125;catch(e)&#123; console.log(e,wb); &#125; return wb; &#125; //给每个单元格进行宽度设置的具体实现 static setCols(sheet,orderNumber,maxCol,tableDatas)&#123; let cols = []; let temp = &#123;&#125;; let count = 0; let tempWidth = 0; for(let key in sheet)&#123; if((/[A-Z]/.test((key.charAt(0)))))&#123; if((key.charAt(0)) == 'A')&#123; temp = &#123;wpx:orderNumber&#125;; cols.push(temp); &#125; else if((key.charAt(0)) == maxCol)&#123; if(tableDatas[count] &amp;&amp; tableDatas[count].width)&#123; tempWidth = parseInt(tableDatas[count].width); temp = &#123;wpx:tempWidth&#125;; cols.push(temp); &#125; break; &#125; else&#123; if(tableDatas[count] &amp;&amp; tableDatas[count].width)&#123; tempWidth = parseInt(tableDatas[count].width); temp = &#123;wpx:tempWidth&#125; cols.push(temp); &#125; &#125; &#125; count++; &#125; return cols;&#125; 以上是已经实现的导出功能，能够实现基本的导出Excel并且将设置的样式导出，但是我在写样式的时候发现一个问题，如果我此时需要每一个单元格自动换行，查了一下资料，发现并没有这个功能。这一块对导出表格的样式大打折扣了。 还有一个问题没有解决，就是现在有一个需求是说要在表格前面加一个选择框，可以单选也可以批量操作，在项目里面使用的elementUI框架，在表格里面有提供一个type=section的属性可以实现这个操作，可是因为在导出的时候导出的是整个的table，然而这个section也是table的一列，因此在导出的时候也会把这个选择框也导出来，最后导出的Excel中的第一列就是空白的。现在正在解决这个问题。希望能尽快解决。","tags":[]},{"title":"纯前端导出Excel","date":"2019-01-08T08:31:45.657Z","path":"2019/01/08/纯前端导出Excel/","text":"需求前提导师提出一个需求实现一个交叉表的展示。简单的说就是在一个excel表格中有一部分主要的列，还有一部分列是不确定的，可能只有一列，也可能有很多列，并且这些数据的样式是可以通过配置去渲染，因此对于这个样式以及数据等等都是动态的。当前台获取到后台的数据的时候，对该数据做了一些格式的转换，并且对表格的样式进行了渲染，所以，如果此时在把表格数据传回后台去做导出，不管是数据还是样式都不太方便，因此，提出了一个前端直接导出Excel的需求。 刚开始没有任何的头绪，后来在找资料的过程中发现了一个叫做js-xlsx的插件（插件的github地址），当然仅仅用这一个插件是不能实现导出的，它必须配合fileSaver才能实现导出，之前也提到说要对表格的样式进行相应的渲染，然而在js-xlsx的api中并没有给出相应的功能，因此，此时还需要用到一个插件叫做xlsx-style,通过这个插件可以给表格设置相应的样式，具体样式如下表所示： 样式属性 子属性 取值 fill patternType “solid” or “none” fgColor COLOR_SPEC bgColor COLOR_SPEC font name “Calibri” // default sz “11” // font size in points color COLOR_SPEC bold true or false underline true or false italic true or false strike true or false outline true or false shadow true or false vertAlign true or false numFmt “0” “0.00%” “0.0%” “0.00%;\\(0.00%\\);\\-;@” “m/dd/yy” alignment vertical “bottom” or “center” or “top” horizontal “bottom” or “center” or “top” wrapText true or false readingOrder 2 // for right-to-left textRotation Number from 0 to 180 or 255 (default is 0) 90 is rotated up 90 degrees 45 is rotated up 45 degrees 135 is rotated down 45 degrees 180 is rotated down 180 degrees 255 is special, aligned vertically border top { style: BORDER_STYLE, color: COLOR_SPEC } bottom { style: BORDER_STYLE, color: COLOR_SPEC } left { style: BORDER_STYLE, color: COLOR_SPEC } right { style: BORDER_STYLE, color: COLOR_SPEC } diagonal { style: BORDER_STYLE, color: COLOR_SPEC } diagonalUp true or false diagonalDown true or false 上表就是整个excel支持的全部样式。 操作步骤 首先我是基于vue去实现的，因此我首先是需要下载依赖，分别下载依赖是xlsx、fileSaver、xlsx-style。 在使用的地方导入相关依赖 123const XLSX = require(\"xlsx\");import FileSaver from \"file-saver\";const xlsxStyle =require(\"xlsx-style\"); 具体的实现 我在实现的过程中因为要对表格的样式进行渲染，因此我需要去做判断哪些需要渲染，这一块是稍微复杂一点的东西。具体的代码含义在代码注释里面也已写出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133 static downloadData(fileName,tableDatas,borderAll)&#123; let domTable = document.querySelector(\"#tableKey\"); //raw:true表示导出的数据全部以字符串形式展示，解决可能出现的格式是百分比，导出却是小数 let wb = XLSX.utils.table_to_book(domTable,&#123;raw:true&#125;); let wbSheet = wb.Sheets.Sheet1; //转化为ASC码的形式 let ascCol = ((wbSheet[\"!ref\"].split(\":\")[1].charAt(0)).charCodeAt() - 1); //得到最大的列 let maxCol = String.fromCharCode(ascCol); //设置每一个单元格的宽度 wbSheet['!cols'] = this.setCols(wbSheet,100,maxCol,tableDatas);; let count = 0; //对每个单元格的样式进行设置 for(let key in wb.Sheets.Sheet1)&#123; if((/[A-Z]/.test((key.charAt(0)))) &amp;&amp; (key.charAt(0)) &lt;= maxCol)&#123; wb.Sheets.Sheet1[key].s = &#123; border:borderAll, numFmt:'', alignment:&#123; horizontal: \"center\", vertical: \"center\" &#125;, font: &#123; name: '宋体', sz: 11, color: &#123;rgb: \"#FF000000\"&#125;, //bold: true, italic: false, underline: false &#125;, &#125; &#125; if((/[B-Z]/.test((key.charAt(0)))))&#123; if((key.charAt(0)) == maxCol)&#123; if(tableDatas[count] &amp;&amp; tableDatas[count].color)&#123; wb.Sheets.Sheet1[key].s = &#123; border:borderAll, numFmt:'', alignment:&#123; horizontal: \"center\", vertical: \"center\" &#125;, font: &#123; name: '宋体', sz: 11, color: &#123;rgb: \"#FF000000\"&#125;, //bold: true, italic: false, underline: false &#125;, fill:&#123; fgColor:&#123; rgb: tableDatas[count].color.split('#')[1] &#125; &#125; &#125; &#125; count = 0; &#125;else&#123; if(((key.charAt(0)).charCodeAt()) &lt;= ascCol)&#123; if(tableDatas[count] &amp;&amp; tableDatas[count].color)&#123; wb.Sheets.Sheet1[key].s = &#123; border:borderAll, numFmt:'', alignment:&#123; horizontal: \"center\", vertical: \"center\" &#125;, font: &#123; name: '宋体', sz: 11, color: &#123;rgb: \"#FF000000\"&#125;, //bold: true, italic: false, underline: false &#125;, fill:&#123; fgColor: &#123; rgb: tableDatas[count].color.split('#')[1] &#125; &#125; &#125; &#125; count++; &#125; &#125; &#125; &#125; //通过fileSaver导出Excel表格 let wbout = xlsxStyle.write(wb, &#123; bookType: 'xlsx', bookSST: true, type: 'buffer' &#125;); try&#123; FileSaver.saveAs(new Blob([wbout],&#123;type : 'application/octet-stream;charset=utf-8' &#125;), fileName + \".xlsx\"); &#125;catch(e)&#123; console.log(e,wb); &#125; return wb; &#125; //给每个单元格进行宽度设置的具体实现 static setCols(sheet,orderNumber,maxCol,tableDatas)&#123; let cols = []; let temp = &#123;&#125;; let count = 0; let tempWidth = 0; for(let key in sheet)&#123; if((/[A-Z]/.test((key.charAt(0)))))&#123; if((key.charAt(0)) == 'A')&#123; temp = &#123;wpx:orderNumber&#125;; cols.push(temp); &#125; else if((key.charAt(0)) == maxCol)&#123; if(tableDatas[count] &amp;&amp; tableDatas[count].width)&#123; tempWidth = parseInt(tableDatas[count].width); temp = &#123;wpx:tempWidth&#125;; cols.push(temp); &#125; break; &#125; else&#123; if(tableDatas[count] &amp;&amp; tableDatas[count].width)&#123; tempWidth = parseInt(tableDatas[count].width); temp = &#123;wpx:tempWidth&#125; cols.push(temp); &#125; &#125; &#125; count++; &#125; return cols;&#125; 以上是已经实现的导出功能，能够实现基本的导出Excel并且将设置的样式导出，但是我在写样式的时候发现一个问题，如果我此时需要每一个单元格自动换行，查了一下资料，发现并没有这个功能。这一块对导出表格的样式大打折扣了。 还有一个问题没有解决，就是现在有一个需求是说要在表格前面加一个选择框，可以单选也可以批量操作，在项目里面使用的elementUI框架，在表格里面有提供一个type=section的属性可以实现这个操作，可是因为在导出的时候导出的是整个的table，然而这个section也是table的一列，因此在导出的时候也会把这个选择框也导出来，最后导出的Excel中的第一列就是空白的。现在正在解决这个问题。希望能尽快解决。","tags":[{"name":"前端技术","slug":"前端技术","permalink":"http://yoursite.com/tags/前端技术/"}]},{"title":"gradle尝鲜","date":"2018-11-21T02:08:31.912Z","path":"2018/11/21/gradle尝鲜/","text":"基本概念gradle是一种自动构建工具，建立在Ant和Maven的基础上。 主流的构建工具Ant(编译，测试，打包) --&gt;Maven(依赖管理，发布) --&gt;Gradle(使用groovy语言，不同于传统的xml文件) groovy语法基础与高校特性基础特性 1.完全兼容Java的语法 2.分号是可选的 3.类、方法默认public 4.编译器自动添加getter/setter 5.属性用点号获取 6.最后一个表达式的值作为返回值，可省略“return”字符串 7.==等同于equals(),不会有空指针异常抛出 高校特性 1.assert语句 2.可选类型定义 3.可选括号 4.字符串 5.集合API 6.闭包 gradle环境安装1.安装JDK 2.Gradle官网下载Gradle包 3.配置系统环境变量GRADLE_HOME 4.添加path：%GRADLE_HOME%\\bin 5.验证：gradle -v idea创建gradle项目1.创建项目，选择gradle 2.点击下一步，自定义以下两个名称 3.点击下一步，按照以下图片勾选，并把本地的gradle和jvm的路径选中，如下图。 4.输入自定义的项目名称，完成项目创建 groovy语法使用实例【注】已创建gradle项目 1.在已创建的gradle项目中点击Tools，按下图选中 2.弹出编码框，并在框中编写一下代码，测试groovy的基础特性 3.同理测试groovy的高效特性 构建Jar包和War包1.构建Jar包：对已经写好的Java文件进行打包； 2.构建War包：对已经写好的Web文件进行打包； 3.对已写好的Java或Web文件进行下图操作，即可在libs文件夹中生成包文件。 4.生成包的位置：libs文件夹里面","tags":[{"name":"构建工具","slug":"构建工具","permalink":"http://yoursite.com/tags/构建工具/"}]},{"title":"生成器Generators","date":"2018-08-20T09:23:25.746Z","path":"2018/08/20/生成器Generators/","text":"生成器函数基本概念概念：它是ES6提供的一种解决异步编程解决方案。 区别（与普通函数）：&lt;/br&gt; 1. 普通函数是通过function声明，生成器函数是用function*声明。 2. 生成器函数中没有return，但是有一个类似return功能的语法：关键字yield,在普通函数中，return只能一次，而在生成器函数中，yield可以有多次，在生成器执行过程中遇到yield表达式会立即暂停，后续可恢复执行状态。 生成器函数实例12345678function* quips(name)&#123; yield &quot;你好&quot; + name + &quot;!&quot;; yield &quot;希望你能喜欢这篇es6的译文&quot;; if(name.startsWith(&quot;X&quot;))&#123; yield &quot;你的名字&quot; + name + &quot; 首字母是X，这很酷！&quot;; &#125; yield &quot;我们下次再见！&quot;&#125; 实例分析： 调用quips() 12345678910&gt;var iter = quips(&quot;Hedy&quot;); undefined&gt;iter.next() &#123;value: &quot;Hedy!&quot;, done: false&#125;&gt;iter.next() &#123;value: &quot;希望你能喜欢这篇es6的译文&quot;, done: false&#125;&gt;iter.next() &#123;value: &quot;我们下次再见！&quot;, done: false&#125;&gt;iter.next() &#123;value: undefined, done: true&#125; &ensp;&ensp;&ensp;&ensp;当在调用一个quips()时，它不会立即执行，返回的是一个指向内部状态的指针对象（遍历器对象）,当后面调用该对象的.next()方法时，函数会执行直到遇到下一个yield表达式，此时会再次暂停执行。即yield表达式是暂停执行标志，next()方法可恢复执行。其中，结果返回的value是表示当前的内部状态的值，即yield表达式后面的值，done则表示是否遍历结束。 &ensp;&ensp;&ensp;&ensp;【注】生成器运行时，它和调用者是处于同一线程中，并且拥有确定的连续执行顺序，永远不会并发。","tags":[{"name":"深入浅出ES6","slug":"深入浅出ES6","permalink":"http://yoursite.com/tags/深入浅出ES6/"}]},{"title":"TCP/IP","date":"2018-08-20T09:23:07.698Z","path":"2018/08/20/TCP.IP/","text":"TCP/IP协议族TCP/IP是互联网相关的各类协议族的总称 TCP/IP的分层管理1. 4层：应用层、传输层、网络层、数据链路层； 2. 各层作用： (1) 应用层：决定了向用户提供应用服务时通信的活动； TCP/IP协议族中预存的应用服务：FTP(文件传输协议)、DNS(域名系统)、HTTP (2) 传输层：对应用层提供处于网络连接中的两台计算机之间的数据传输； 协议：TCP(传输控制协议) 和 UDP(用户数据报协议) (3) 网络层：处理在网络上流动的数据包。数据包是传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。 (4) 链路层（网络接口层）：处理连接网络的硬件部分。硬件范畴均在链路层的作用范围内。 TCP/IP通信传输流1. 利用TCP/IP协议族进行网络通信时，会通过分层顺序进行通信。发送端从应用层往下，接收端则往应用层上走。 2. 发送端在层与层之间传输数据时，每经过一层必被打上一个该层所属的首部信息，反之，接收端在层与层传输数据时，每经过一层就把对应的首部去掉。 3. 封装：把数据信息包装起来的做法。 与HTTP关系密切的协议：IP、TCP、DNS1. 负责传输的IP协议（网际协议）[位于网络层] (1) 作用：把各种数据包传送给对方。 (2) 两个条件确保发送：IP地址和MAC地址。 IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可和MAC地址进行配对，其中IP地址可变换，但MAC地址基本不会更改。 2. 确保可靠的TCP协议[位于传输层] (1) 提供可靠的字节流服务 (2) 字节流服务：为了方便传输，将大块数据分割成以报文段位单位的数据包进行管理，还能够确认数据是否送达到对方。 (3) 确保数据到达目标采用三次握手策略，握手过程中使用TCP标志---SYN和ACK. 第一次握手：发送端发送一个带SYN标志的数据包给接收端； 第二次握手：接收端收到发送端发过来的数据包后，回传一个带有SYN/ACK标志的数据包传达确认信息； 第三次握手：发送端收到接收端回传的数据后，在回传一个带ACK标志的数据包。此时，完成连接过程。 3. DNS服务[位于应用层] 提供通过域名查找IP地址或逆向从IP地址反查域名的服务 4. URI和URL (1) 统一资源标识符（URI[Uniform Resource Identifier]）:由某个协议方案表示的资源的定位标识符。URL表示资源的地点，因此URL是URI的子集 协议方案：指访问资源使用的协议类型的名称。如使用HTTP协议，协议方案就是http。","tags":[{"name":"图解HTTP","slug":"图解HTTP","permalink":"http://yoursite.com/tags/图解HTTP/"}]},{"title":"HTTP","date":"2018-08-20T09:22:55.242Z","path":"2018/08/20/HTTP/","text":"HTTP不保存状态的协议1. HTTP是一种无状态协议，对发送过的请求或相应不做持久化的处理。 2. HTTP/1.1虽然是无状态协议，利用Cookie实现了保持状态的功能。 HTTP中的方法1. GET：获取资源，请求访问已被URI识别的资源，返回报文主体部分。 2. POST:传输实体的主体。主要目的：不是获取响应的主体内容。 3. PUT:传输文件。该方法自身不带验证机制，存在安全问题。 4. HEAD:获得报文首部。与GET方法一样，但不返回报文主体部分。可用于确认URI的有效性及资源更新的额日期时间等。 5. DELETE:删除文件。与PUT方法相反，按指定URI删除指定的资源。也存在安全问题。 6. OPTIONS:询问支持的方法。用来查询针对请求URI指定的资源支持的方法。 7.TRACK:追踪路径。 8. CONNECT:要求用隧道协议连接代理。主要使用SSL（Secure Sockets Layer安全套接层）和TLS（Transport Layer Sercurity传输层安全）协议把通信内容加密后经网络隧道传输。 持久连接1. 持久连接：也称HTTP keep-alive 或 HTTP connection reuse 2. 特点：只要任意一端没有明确提出断开连接，则保持TCP连接状态。 3. 好处：减少TCP连接的重复建立和断开所造成的的额外开销，减轻服务器端的负载。 4. 在HTTP/1.1中默认连接都是持久连接。 HTTP状态码1. 1xx:信息性状态码；原因：接收的请求正在处理。 2. 2xx：成功状态码；原因：请求正常处理完毕。 200：OK；客户端发来的请求在服务器端正常处理了。 204：No Content；请求已被成功处理，但是在返回的响应报文中不含实体的主体部分。浏览器显示的页面不发生更新。 206：Partial Content；客户端进行范围请求，服务器成功执行了这部分GET请求。 3. 3xx：重定向状态码；原因：需要进行附加操作以完成请求。 301：Moved Permanently；永久性重定向，表示请求的资源已被分配了新的URI。 302：Found；临时重定向，跟301差不多，只是302代表的资源不是被永久移动。 303：See Other；表示请求对应的资源存在着另一个URI,应使用GET方法定向获取请求资源。 304：Not Modified；表示客户端发送附带条件的请求时，服务器端允许请求访问资源。 307：Temporary Redirect；临时重定向。 4. 4xx：客户端错误状态码；原因：服务器无法处理请求。 400：Bad Request；表示报文中存在语法错误。 401：Unauthorized；表示发送的请求需要有通过HTTP认证的认证信息。 403：Forbidden；表示对请求资源的访问被服务器拒绝了。 404：Not Found；表示服务器上无法找到请求的资源。 5. 5xx：服务器错误状态码；原因：服务器处理请求出错。 500：Internal Server Error；表示服务器在执行请求时发生了错误。 503：Service Unavailable；表示服务器暂时处于超负载或正在进行停机维护。现在无法处理请求。","tags":[{"name":"图解HTTP","slug":"图解HTTP","permalink":"http://yoursite.com/tags/图解HTTP/"}]},{"title":"2018.7.26分享总结","date":"2018-07-27T03:24:17.182Z","path":"2018/07/27/2018.7.26分享总结/","text":"原型prototype定义：是function对象的一个属性，它定义了构造函数构造出的对象的公共祖先，通过该构造函数产生的对象，可以继承该原型的属性和方法。【注】:(1) 原型也是一个对象(2) 不能通过构造出的实例去更改原型的属性(3) 每一个function对象都会自带一个prototype属性以及一个proto属性(4) 每一个对象都会自带一个proto属性 __proto__原型作为对象的内部属性，是不能被直接访问的，所以，部分浏览器提供“proto”的访问器去访问原型。其中实例的proto和构造函数的原型完全相等。如下代码所示： 12345function Car()&#123;&#125;var car = new Car();console.log(car.__proto__ === Car.prototype); //true 关系图如下： constructorconstructor是原型的一个属性，指向关联的构造函数。如下代码所示： 12345function Car()&#123;&#125;var car = new Car();console.log(Car.prototype.constructor === Car); //true 关系图如下： 用法：1.将公有元素保存到原型里面实例1： 123456789function Car(color,owner)&#123; this.owner = owner; this.carName = &quot;BMW&quot;； this.height = 1400; this.lang = 4900; this.color = color;&#125;var car = new Car(&apos;red&apos;,&apos;hedy&apos;); 上面的代码每次执行都会去执行流程化生产的属性，例如carName，height等，造成代码冗余，解决这个问题，将共有代码提到原型里面，原型只需要加载一次，不用每次执行都去加载，然后根据原型继承，可在实例中使用。改造后的代码如下： 12345678Car.prototype.carName = &quot;BMW&quot;;Car.prototype.height = 1400;Car.prototype.lang = 4900;function Car(color,owner)&#123; this.owner = owner; this.color = color;&#125;var car = new Car(&apos;red&apos;,&apos;hedy&apos;); 原型链123456789101112131415Grand.prototype.name = &quot;hedy&quot;function Grand()&#123;&#125;var grand = new Grand();Father.prototype = grand;function Father()&#123; this.name = &quot;judy&quot;;&#125;var father = new Father();Son.prototype = father;function Son()&#123; this.hobbit = &quot;smoking&quot;;&#125;var son = new Son(); 如上代码中，当打印son.name时，在Son自己的构造方法里面是找不到name属性的，然后就顺着son.proto，也就是Father.prototype中去查找，自然找到并打印judy，此时，可以看到在代码中Grand原型里面也有一个name属性，但是js查找过程是就近原则，最先找到谁就是谁，后面不会再去查找。不难看出，son，father以及grand之间是通过proto去连接的，查找的时候也是根据这个属性一级一级往上查找。 关系图如下： 如上图所示，此处只画了grand到object两个阶段，可以看到该条原型链最终指向的是null，因此，该原型链的终端就是object.prototype。 提问：是否所有对象最终都会继承自Object.prototype。答：不是，有特例。当使用Object.create()创建一个具有指定原型且可选择性的包含指定属性的对象，可传两个参数，第一个是prototyoe，必须，可以是null；第二个参数是可选的。当传入的第一个参数是null时，返回回来的对象是没有原型的，所以它不存在继承自Object.prototype. 如此下图所示： 原型陷阱12345678910Person.prototype.name = &quot;sunny&quot;;function Person()&#123; &#125;var person = new Person();Person.prototype = &#123; say:function()&#123; console.log(&quot;hehe&quot;) &#125;&#125; 当对原型对象执行完全替换的时候，可能会触发原型链中的某种异常，并且当重写了某对象的prototype时，该对象原型的constructor指向的是Object而不是Person，因此，当重写了某对象的prototype时，需要重置一下constructor方法，即Person.prototype.constructor = Person. Ajax定义：相当浏览器和服务器的中间层，其中最重要的是对象XMLHttpRequest对象。状态（readyState）：分为以下5种：① 0：未初始化状态（此时刚创建XMLHttpRequest实例）② 1：启动状态（此时调用open方法）③ 2：发送状态（调用send方法，但此时已经有部分数据被接收）④ 3: 接收状态（对数据进行接收及处理）⑤ 4：完全接收数据并完成数据的处理 方法(1) onreadystatechange:该方法会在readystate的状态改变时触发。(2) open(method,url,true/false):强调第三个参数，主要是同步和异步的控制，默认是true，异步方式。(3) send():参数格式：null，xml，.txt(4) setRequestHeader():发送时可设置请求头(5) getResponsHeader():接收响应数据(6) overrideMimeType():决定内容用什么形式显示(7) onloadend():error时触发或者调abort时主动触发或者请求完成时触发(8) post：载体：http键值对形式，以form形式提交(9)get：载体：直接在http中 封装1.axios（原理参照promise）&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;特性：(1) 拦截请求并响应&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;(2) 自动转换json格式&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;(3) 客户端支持跨域伪造&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;(4) axios.get(url,配置,数据).then&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;(5) 并发请求2.fetch","tags":[{"name":"分享总结","slug":"分享总结","permalink":"http://yoursite.com/tags/分享总结/"}]},{"title":"CSS Sprite","date":"2018-07-17T09:03:16.426Z","path":"2018/07/17/CSS Sprite/","text":"简介css雪碧（精灵）是一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，利用css的背景定位来显示需要的部分，即background-position：x y； 原理把网站上需要用到的图片整合到一张单独的图片中，从而减少网站的http请求数量，其中，图片是在CSS中定义。 优点1. 减少加载网页图片时对服务器的请求次数 提高页面的加载速度 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!-- html实现--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;BOM&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;cat&quot;&gt; &lt;ul&gt; &lt;li class=&quot;cat-1&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;h3&gt;服饰内衣&lt;/h3&gt; &lt;/li&gt; &lt;li class=&quot;cat-2&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;h3&gt;鞋包配饰&lt;/h3&gt; &lt;/li&gt; &lt;li class=&quot;cat-3&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;h3&gt;运动户外&lt;/h3&gt; &lt;/li&gt; &lt;li class=&quot;cat-4&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;h3&gt;珠宝手表&lt;/h3&gt; &lt;/li&gt; &lt;li class=&quot;cat-5&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;h3&gt;手机数码&lt;/h3&gt; &lt;/li&gt; &lt;li class=&quot;cat-6&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;h3&gt;家电办公&lt;/h3&gt; &lt;/li&gt; &lt;li class=&quot;cat-7&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;h3&gt;护肤彩妆&lt;/h3&gt; &lt;/li&gt; &lt;li class=&quot;cat-8&quot;&gt; &lt;i&gt;&lt;/i&gt; &lt;h3&gt;母婴用品&lt;/h3&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!-- css实现--&gt; h3 ul&#123; margin: 0; padding: 0; &#125; h3&#123; display: block; margin: 0; padding: 0; &#125; .cat&#123; position: relative; width:150px; background:#f8f8f8; border:1px solid #bbb; &#125; ul&#123; list-style: none; &#125; li&#123; z-index: 2; position: relative; display: block; height:31px; line-height: 31px; overflow: hidden; //margin:1px 10px 0; vertical-align: bottom; border-bottom: 1px solid #dedede; &#125; li:hover&#123; background-color: #666666; &#125; li h3&#123; font-size: 14px; font-weight: 400; &#125; li i&#123; display: inline; float: left; margin: 3px 10px 0 0; height: 24px; width: 30px; &#125; li &gt; i&#123; background:url(&apos;http://img.mukewang.com/539a950e00015ba500710200.jpg&apos;); &#125; .cat-2 &gt; i&#123; background-position: 0 -24px; &#125; .cat-3 &gt; i&#123; background-position: 0 -48px; &#125; .cat-4 &gt; i&#123; background-position: 0 -72px; &#125; .cat-5 &gt; i&#123; background-position: 0 -96px; &#125; .cat-6 &gt; i&#123; background-position: 0 -120px; &#125; .cat-7 &gt; i&#123; background-position: 0 -144px; &#125; .cat-8 &gt; i&#123; background-position: 24px -168px; &#125;","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"构建es6环境","date":"2018-06-01T14:00:44.072Z","path":"2018/06/01/构建es6环境/","text":"项目目录创建1. 在es6项目问价下创建3个目录文件 app server tasks2. 在app下创建 css js views3. 在app/js下创建 index.js [入口文件] 创建class文件夹 &ensp;&ensp;&ensp;&ensp;app/class下创建test.js4. 在app/views下创建 error.ejs index.ejs [相当于html使用]5. 在es6目录下创建设置babel编译工具配置文件.babelrc6. 在es6下创建gulpfile.babel.js文件## 命令行处理、创建js编译任务1. 进入es6/server目录中 启动脚手架，表示启用ejs模板引擎 123express -e执行 npm install || cnpm install2. 在es6/tasks目录下创建util文件 在es6/tasks/util文件下创建args.js文件【注意】：在项目根目录中创建package.json依赖包文件（配置依赖），使用以下命令： 1npm init || cnpm init3. 编写args.js命令行处理文件 123456789101112131415161718192021222324252627282930313233import yargs from &apos;yargs&apos; //对参数进行操作 const args = yargs .option(&apos;production&apos;,&#123; boolean:true, default:false, //命令中没有production时，默认为开发环境，有就为线上环境 describe:&apos;min all script&apos; &#125;) //设置要不要自动编译 .option(&apos;watch&apos;,&#123; boolean:true, default:false, describe:&apos;watch all files&apos; &#125;) //设置是否需要输出编译日志 .option(&apos;verbose&apos;,&#123; boolean:true, default:false, describe:&apos;log&apos; &#125;) //处理压缩 .option(&apos;sourcemaps&apos;,&#123; describe:&apos;fource the creation of sourcemape&apos; &#125;) //设置服务器端口 .option(&apos;port&apos;,&#123; string:true, default:8080, describe:&apos;server port&apos; &#125;) .argv //以字符串形式解析 export default args;4. 在tasks目录下创建构建脚本script.js文件并编写script.js文件 ① 使用以下命令安装该代码中需要导入的依赖【注：后面不在重复展示安装依赖的过程】 12npm install gulp gulp-if gulp-concat webpack webpack-stream vinyl-named gulp-livereload gulp-plumber gulp-rename gulp-uglify gulp-util yargs --save-dev ② 编写scripts代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import gulp from &apos;gulp&apos;; //整个的构建都是基于gulpimport gulpif from &apos;gulp-if&apos;; //gulp语句中做if判断的import concat from &apos;gulp-concat&apos;; //gulp中处理文件拼接import webpack from &apos;webpack&apos;; //打包工具import gulpWebpack from &apos;webpack-stream&apos;;import named from &apos;vinyl-named&apos;; //做重命名标志的import livereload from &apos;gulp-livereload&apos;;//热中心，文件自动刷新import plumber from &apos;gulp-plumber&apos;;//处理文件信息流import rename from &apos;gulp-rename&apos;;//重命名import uglify from &apos;gulp-uglify&apos;;//处理压缩的import &#123;log,colors&#125; from &apos;gulp-util&apos;;//命令行输出的import args from &apos;./util/args&apos;;//利用gulp创建脚本任务gulp.task(&apos;scripts&apos;,() =&gt; &#123;return gulp.src([&apos;app/js/index.js&apos;]) //处理异常 .pipe(plumber(&#123; errorHandle:function()&#123; &#125; &#125;)) .pipe(named()) .pipe(gulpWebpack(&#123; module:&#123; loaders:[&#123; test:/|.js$/, loader:&apos;babel-loader&apos; &#125;] &#125; &#125;),null,(err,stats) =&gt; &#123; log(`Finished &apos;$&#123;colors,cyan(&quot;scripts&quot;)&#125;&apos;`,stats.toString(&#123; chunks:false &#125;)) &#125;) .pipe(gulp.dest(&apos;server/public/js&apos;)) // 必须uolify放到server上才额能运行 .pipe(rename(&#123; basename:&apos;cp&apos;, extname:&apos;.min.js&apos; &#125;)) //重命名 .pipe(uglify(&#123;compress:&#123;properties:false&#125;,output:&#123;&apos;quote_keys&apos;:true&#125;&#125;)) //压缩 .pipe(gulp.dest(&apos;server/public/js&apos;)) //监听文件，变化自动刷新 .pipe(gulpif(args.watch,livereload())) &#125;)5. 在tasks目录下创建处理模板的脚本page.js文件 1234567891011import gulp from &apos;gulp&apos;; //整个的构建都是基于gulpimport gulpif from &apos;gulp-if&apos;; //gulp语句中做if判断的import livereload from &apos;gulp-livereload&apos;;//热中心，文件自动刷新import args from &apos;./util/args&apos;;gulp.task(&apos;pages&apos;,() =&gt; &#123; return gulp.src(&apos;app/**/*.ejs&apos;) .pipe(gulp.dest(&apos;server&apos;)) .pipe(gulpif(args.watch,livereload())) //监听热更新&#125;)6. 在tasks目录下创建处理css的脚本css.js 12345678910import gulp from &apos;gulp&apos;; //整个的构建都是基于gulpimport gulpif from &apos;gulp-if&apos;; //gulp语句中做if判断的import livereload from &apos;gulp-livereload&apos;;//热中心，文件自动刷新import args from &apos;./util/args&apos;;gulp.task(&apos;css&apos;,() =&gt; &#123; //打开文件，并复制到server/public下，**表示全部的，*表示.css文件，包括嵌套文件 return gulp.src(&apos;app/**/*.css&apos;) .pipe(gulp.dest(&apos;server/public&apos;))&#125;)7. 在tasks目录下创建处理服务器的脚本server.js 12345678910111213141516171819202122232425262728import gulp from &apos;gulp&apos;; //整个的构建都是基于gulpimport gulpif from &apos;gulp-if&apos;; //gulp语句中做if判断的import liveserver from &apos;gulp-live-server&apos; //启动服务器的包import args from &apos;./util/args&apos;;//启动服务gulp.task(&apos;server&apos;,(cb) =&gt; &#123; //如果不在监听状态下，返回回调函数 if(!args.watch) return cb(); //在监听条件下，创建服务器 var server = liveserver.new([&apos;--harmony&apos;,&apos;server/bin/www&apos;]); server.start(); //启动服务器 //监听server目录下的js、ejs改变时热更新 gulp.watch([&apos;server/public/**/*.js&apos;,&apos;server/views/**/*.ejs&apos;],function(file)&#123; //通知服务器问价改变 server.notify.apply(server,[file]); &#125;) //监听需要重启服务的文件 gulp.watch([&apos;server/routes/**/*.js&apos;,&apos;server/app.js&apos;],function()&#123; //重启服务器 server.start.bind(server)(); //调用server的start的api &#125;); &#125;)8. 在tasks目录下创建default.js文件 12345import gulp from &apos;gulp&apos;; //整个的构建都是基于gulp //如果gulp执行答default就去找build.js文件gulp.task(&apos;default&apos;,[&apos;build&apos;]);9. 编写gulpfile.babel.js文件 123import requireDir from &apos;require-dir&apos;;requireDir(&apos;./tasks&apos;);10. 编写.babelrc文件【注：需要入住依赖babel-preset-es2015】 1234&#123; &quot;presets&quot;:[&quot;es2015&quot;]&#125;11. 运行gulp –watch 未报错，但是无法运行，运行命令结果如下图： 最终问题在server.js里面的一个重启服务的文件函数调错了，具体如下图：","tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"Ajax基础知识","date":"2018-03-16T13:41:10.721Z","path":"2018/03/16/ajax基础/","text":"Ajax简介 Ajax（Asynchronous JavaScript and XML）= 异步JavaScrip和XML,用于创建快速动态网页的技术，可以使网页实现异步更新，不用重新加载整个页面的情况下，对网页的局部更新。 Ajax基于现有的Internet标准，并且联合使用以下几种语言： ①：XMLHttpRequest对象(异步的与服务器交换数据) ②：JavaScript/DOM(信息显示/交互) ③：CSS(给数据定义样式) ④：XML(作为转换数据的格式) Ajax创建XMLHttp对象 创建XMLHttpRequest对象： 12variable = new XMLHttpRequest();variable = new ActiveObject(&quot;Microsoft.XMLHTTP&quot;); &lt;!--老版本的Intenet Explorer--&gt; 【注】首先检查是否存在“XMLHttpRequest”，代码如下： 12345if(window.XMLHttpRequest)&#123; xmlhttp = new XMLHttpRequest();&#125;else&#123; xmlhttp = new ActiveObject(&quot;Microsoft.XMLHTTP&quot;);&#125; 向服务器发送请求 XMLHttpRequest对象用于和服务器交换数据，所以如果需要请求发送到服务器，则使用该对象中的open()和send()方法。当open中第三个参数为false时，不可以编写onreadystatechange函数，只需要把代码放到send()语句后即可。若第三个参数为true，则需要规定在响应处于onreadystatechange事件中的就绪状态时执行函数， 123456789101112&lt;!-- 当第三个参数为true时执行onreadystatechange--&gt;xmlhttp.onreadystatechange=function()&#123; &lt;!--当readState等于4且状态为200时表示响应已经就绪--&gt; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; &#125;&#125;xmlhttp.open(&quot;GET&quot;,&quot;info.txt&quot;,true);&lt;!-- 第一个参数表示请求的类型，即GET或PSOT，第二个参数表示文件在服务器上的位置，第三个参数表示同步或一异步，即true表示异步，false表示同步--&gt;xmlhttp.send(); &lt;!-- 只使用post请求--&gt; 在open方法中，但使用GET方法请求时，读取的文件有可能是缓存中的结果，所以为了避免这种情况，一般会在URL上加一个唯一的ID，如果需要发送信息，也在URL上添加信息。当使用POST方法时，可用setRequestHeader()来添加HTTP头，然后在send方法中添加需要发送的数据。【注】在方法setRequestHeader(header，value)中有链各个参数，第一个是规定头的名称，第二个是规定头的值 Ajax服务器响应 XMLHttpRequest对象中的responseText 和responseXML 属性: ①：responseText：获得字符串形式的响应数据； ②：responseXML：获得XML形式的响应数据。 如果服务器的响应是 responseXML，则需要作为XML对象解析，如下代码： 12345678xmlDoc=xmlhttp.responseXML;txt=&quot;&quot;;x=xmlDoc.getElementsByTagName(&quot;ARTIST&quot;);for (i=0;i&lt;x.length;i++)&#123; txt=txt + x[i].childNodes[0].nodeValue + &quot;&lt;br&gt;&quot;;&#125;document.getElementById(&quot;myDiv&quot;).innerHTML=txt; onreadystatechange 事件 当请求被发送到服务器端的时候，需要执行一些基于响应的任务，每当readyState改变时，就会触发该事件，readyState属性存有XMLHttpRequest的状态信息。readyState状态从0到4的变化如下： ①：0：请求未初始化； ②：1：服务器连接已建立； ③：2：请求已接收; ④：3：请求处理中； ⑤：4：请求已完成，且响应已就绪。status的状态： ①：200：“ok”； ②：404：未找到页面。 基础知识铺垫 客户端与服务器概述 客户端主流操作系统：windows、mac、Linux 服务端操作系统：Linux、unix 客户端应用：qq、播放器、浏览器 服务端应用：网页服务（Apache、Nginx、tomcate（java）、iis（微软））、邮件服务（posfix）、文件上传下载服务（vsftp） 计算机通信协议 计算机组成： cpu（运算器和控制器）、存储器（硬盘、内存）、输入、输出设备 计算机运行机制：输入设备将数据发到cpu，cpu将数据传输到存储器（必须经过内存去访问硬盘），存储器传到输出设备（开机时所有数据会存储在存储器中）注意： 内存：程序一开始是在磁盘上，要想运行必须首先加载在内存 网络相关概念 IP地址：xxx.xxx.xxx.xxx 端口：用来区分电脑上的特定应用网络程序 域名：IP的别名（可以买卖） 域名和IP地址：对应关系不一定是一对一的 访问 http://www.baidu.com时： 1.域名解析 2.通过解析道德IP地址找到对应的计算机 DNS 配置网站服务器 前端和后端的角色分工 B/S:brower 浏览器，server 服务器 C/S：clienc 客户端（qq），server 服务器 如果一个功能有改进，所有使用的人都需要更新 同步和异步 同步：阻塞（白屏，整个页面刷新） 异步：（页面不全部刷新，局部刷新） 浏览网页的时候两种情况： 1.白屏（同步）； 2.页面不刷新（异步） 局部更新页面不会全屏刷新 实现异步局部更新（不使用XMLHttpRequest对象） 原生ajax实现异步通信","tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"计算机网络（网络层）","date":"2018-03-15T06:51:19.469Z","path":"2018/03/15/计算机网络（网络层）/","text":"网际协议IP是TCP/IP体系中最主要协议之一，以IP协议配套使用的三个协议：①：地址解析协议ARP;②：网际控制报文协议ICMP；③：网际组管理协议IGMP; 将网络互相连接起来的一些中间设备： ①：物理层使用的中间设备是转发器； ②：数据链路层使用的中间设备是网桥或桥接器； ③：网络层使用的中间设备叫做路由器； ④：在网络层以上使用的中间设备叫网关； IP地址由网络号和主机号构成，并且在整个因特网范围内是惟一的。 IP地址分类：（A,B,C类地址是单播地址，一对一通信，D类是多播地址，一对多通信，E类是保留） ①：A类：网络号：前8位，主机号后24位； ②：B类:网路号：前16位，主机号后16位； ③：C类：网络号:前24位，主机号后8位； IP的指派范围： ①：A类：1 - 126； ②：B类：128 - 191 ③：C类：192 - 223","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"初入Vue(一)","date":"2018-03-03T07:36:36.715Z","path":"2018/03/03/初入Vue(一)/","text":"接上一篇出现的问题，现在基本懂了，因为在vue2中对HTML和body标签做了限制，其具体源码如下：12345678910111.src/entries/web-runtime-with-compiler.jsel = el &amp;&amp; query(el) /* istanbul ignore if */ if (el === document.body || el === document.documentElement) &#123; process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn( `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.` ) return this &#125;","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"初入Vue","date":"2018-02-26T03:03:18.918Z","path":"2018/02/26/初入vue/","text":"&ensp;&ensp;&ensp;&ensp;刚开始接触vue，遇到一个不知道什么问题的问题，百度有人说是js的引入顺序问题，但是我是我引入顺序是正确的，还是没有得到答案。接下来说说问题：1234567891011121314151617181920212223242526272829303132&lt;script src=&quot;../vueBasic/vue.min.js&quot;&gt;&lt;/script&gt;&lt;body id=&quot;example&quot;&gt; &lt;ul &gt; &lt;li v-for=&quot;item in items&quot;&gt; &#123;&#123;item.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;script&gt;var demo = new Vue(&#123; el: &apos;#example&apos;, data: &#123; items: [ &#123; name:&apos;kuaiche&apos;, tag:1 &#125;, &#123; name:&apos;chuzuche&apos;, tag:3 &#125;, &#123; name:&apos;shunfengche&apos;, tag:2 &#125;, &#123; name:&apos;zhuangche&apos;, tag:0 &#125; ] &#125;&#125;)&lt;/script&gt; &ensp;&ensp;&ensp;&ensp;这是所有的代码，运行的时候会发现出现的结果并不是期待的列表顺序结果而是如图所示： &ensp;&ensp;&ensp;&ensp;学习vue遇到的第一个坑，目前找到的解决办法是在ul标签外面加一层div，并且设置id即可正常显示，但是现在我不知道为什么。等后面知道了原理再来解释。 修改后的html代码：1234567&lt;body&gt; &lt;div id=&quot;example&quot;&gt; &lt;ul &gt; &lt;li v-for=&quot;item in items&quot;&gt; &#123;&#123;item.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"块数据","date":"2018-02-06T02:25:30.251Z","path":"2018/02/06/代码重构/","text":"公务接待重构&ensp;&ensp;&ensp;&ensp;最近需求一直在改，每次都在原来的基础上加一些新的东西，但是到后来发现整个文件里面的代码特别乱，而且特别杂，注释也没有，有时候都不知道自己写的是什么功能，所以，决定把代码重构一波。 &ensp;&ensp;&ensp;&ensp;以前没有做过重构代码这种事情，这次是第一次，第一次重构代码给我的感觉就是，一边抱怨自己为什么当时不写个注释什么的，为什么不能再最开始写的时候多想想拓展性，另一边则一个一个方法的去看是什么功能，能不能把它写得更简单，能不能把里面的部分方法抽取出来，让整个文件的封装性更加的好。而且因为有些功能已经写了很久了，然后又没有加注释，所以有些状态的转化都已经忘记了，所以在我看来，重构代码真的不是痛苦的过程而是非常痛苦的过程。 &ensp;&ensp;&ensp;&ensp;我首先是重构的一个表单的提交页面，因为是手机端，所以需要注意的问题比pc端需要注意的问题更多。例如安卓和苹果的兼容性，而且在这个表单的提交页面上有很多的跨页面选择，填写数据，因此去处理跨页面保存数据也是一个问题，在这里，我使用的是==angular==的$rootScope来保存临时的数据，当需要的数据被保存以后，将$==rootScope==清空。整个过程让采用的是==ionic==加上angular，所以在使用ionic的插件的时候还得去考虑是否在苹果手机上展示的效果和需求要的效果是一样的。 &ensp;&ensp;&ensp;&ensp;值得庆幸的是这个过程中并没有遇到什么解决了很久都没有解决的问题。一般都是一点小小的问题，调试一下就可以搞定。 &ensp;&ensp;&ensp;&ensp;接下来说说后台的代码，因为我们用的是自己实验室封装的框架，所以很多的基础代码就直接通过创建实体的时候就已经生成好了，我要做的就是在已有的方法的基础上添加自己想要的方法，但是因为中间过程这一个文件有很多人在操作，每个人都写了一套自己的方法，导致整个后台的代码就显得特别的冗余，有很多可以共用的方法也没有被抽取出来。因为我是这一块的主要负责人，所以最后还是得我自己来把整个后台的代码也重新整理了一遍。 &ensp;&ensp;&ensp;&ensp;整个代码的重构过程花了大概5天的时间，当然，如果按完整的一天来算的话，大概也就2-3天的时间，只是这5天每天都有在做这个事情。现在基本完成了，回过头去看已经重构好的代码，没有了以前的冗余，加上了该有的注释，让整个代码都显得清晰明了，重构后的代码也将封装性，拓展性做的比之前更好一点。 通过这次重构代码的经历，也让我汲取了一些教训： 1. 写代码之前将需求搞清楚，思考清楚该怎么写，有没有效率更好的方法2. 每写一个方法或者一个不太清楚的变量都应该加上该有的注释，这样在以后别人看或者自己去看代码的时候才会知道这个方法是干什么的，不然可能就会变成，别人在看你代码的时候，一边看一边骂。3. 在一个就是封装性和拓展性以及兼容性，这三个部分是分厂重要的，做好了这3个部分可以减少很多的代码量，让整个代码看起来很清晰简洁。 第一次重构代码的一点感想，还是记录一下。","tags":[{"name":"代码重构","slug":"代码重构","permalink":"http://yoursite.com/tags/代码重构/"}]},{"title":"html5基础知识","date":"2018-01-24T02:12:58.062Z","path":"2018/01/24/html5基础知识/","text":"html5知识点总结 进度条：progress标签，如果要修改进度条样式，设置-webkit-apprearant：none。 多媒体的标签：audio:音频；vadio：视频。 新选择器（js里面的操作）：document.querySelector(‘.item’) —&gt; 返回dom对象；nt.querySelectorAll(‘.item’) —&gt; 返回元素类型是dom类型的数组.提示: $(‘.item’) —&gt; 返回一个jquery对象（实则是dom元素的数组，只是经过jquery封装） classList属性： eg:1234&lt;h1 class=&quot;class1 class2 class3&quot;&gt;&lt;/h1&gt;var h1 = document.getElementByTagName(&apos;h1&apos;)[0]var list = h1.classlist; 提示： 通过classList封装一些针对增加、删除、切换的方法，add(‘newClass’)、remove(‘oldClass’)、toggle(‘cl’)，存在的话就删除，不存在的话就添加 网页的离线访问—application cache 正常 应用程序缓存 html里面添加一个mainfest属性指向一个文件提示：文件：一般取名为cache.mainfest,在文件里面添加的内容为12345678910CACHE MANIFEST# version 1.0.1 CACHE: studyHtml5.html studyHtml5.js studyCss3.css NETWORK: * 注意：在cache：里面必须有一个tab键。 html各种标签属性及一些面试常问基础知识点 lang=’en,zh’：告诉搜索引擎爬虫，使其精确识别 ol标签上的常用属性：type、reversed、startwt ul标签上的常用属性:type 协议限定符： 1&lt;a href=&quot;javascript:&quot;&gt;email me&lt;/a&gt; 主流浏览器及其内核:ie（trident）、google（webkit/blink）、opera（presto）、safari（webkit）、firefox（gecko）。 css中各种类型的样式占的权重：！important — 正无穷、行间样式—1000、id选择器样式—100、class/属性/伪类选择器:10、通配符—0 样式垂直居中：用容器的height等于line-height 首行缩进：text-indent:2em；1em=16px=font-size（默认16px） 行级元素：span、strong、em、a、del 块级元素：div、p、ul、li、img、form、address 行级块元素：img 省略号：overflow:hidden;white-space:nowrap;text-overflow:ellipsis; 强制不换行：white-space:nowrap; 选择器：eg： 12345678910111213直接子元素选择器div &gt; em&#123;color:red;并列选择器div.demo .ttt&#123; background-color: red;&#125;分组选择器p, div, span&#123; background-color: red;&#125; js知识点总结 预编译过程 创建AO（执行期上下文）对象（全局的预编译生成GO对象） 将形参和变量名作为AO or GO的属性名，值为undefined 将实参的值和形参统一 在函数体里面找函数声明，值赋予函数体 作用域链（每一个函数定义的时候都会产生一个执行器上下文） eg 12345678910 a 被定义：创建a[[scope]] --&gt; GO a 被执行：将a的AO入栈到a[[scope]] function a()&#123;function b()&#123; var b = 123; &#125;var a = 234;b(); &#125; a();","tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"springIoc","date":"2017-11-28T09:34:02.825Z","path":"2017/11/28/springIOC/","text":"简易spring的IOC实现 &ensp;&ensp;&ensp;&ensp;首先需要理解一下什么叫做ioc（inversion of Controller），简单来说就是控制反转。它不是一门像js这样的技术，我们可以把它看做一种设计模式。为什么会出现IOC呢？&ensp;&ensp;&ensp;&ensp;传统的程序会导致类与类之间高耦合，难以测试，于是就把创建和查找依赖对象的控制权都交给一个容器，由容器来进行注入组合对象。这里可以把容器比作一个菜篮，以前没有菜篮的时候去买白菜的时候就特别不方便，后来有了篮子，不仅装东西方便，而且还送货上门，你只需要说一声，我需要白菜，直接送到家门口。spring就相当于这个篮子。它体现了一个法则：“不管怎样都不要来找我们，我们有需要的时候回来找你的”。接下来我就把一个简易的spring的IOC展示出来。 主要步骤 写一个IOC的类，用来解析配置文件，当然配置文件有很多种，但是这里我就用了一个xml的配置文件。这里面要用到反射的知识。 遍历xml文件中的所有的bean标签 获取bean标签里面的id和class属性，加载class对应的类，并创建bean 获取property标签的属性值，并填充到bean中 将bean注册到bean容器中 主要文件 首先有一个xml文件，我给它取名为springIoc 然后是读取xml文件的MySimpleIOC文件 然后有实体类，也就是model，我这里用了Student和studentClass 最后就是一个测试类（我用的是junit进行的测试） 关键代码展示[^code]&ensp;&ensp;&ensp;&ensp;这里主要是读取xml文件的整个过程，也是整个实现IOC的关键，至于其他的就不做过多的阐述 public MySimpleIOC(String location) throws Exception{ loadBeans(location); } private void loadBeans(String location) throws Exception { //加载xml配置文件 InputStream inputStream = new FileInputStream(location); DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder docBuilder = factory.newDocumentBuilder(); Document doc = docBuilder.parse(inputStream); Element root = doc.getDocumentElement(); NodeList nodes = ((Node) root).getChildNodes(); for(int i = 0;i &lt; nodes.getLength();i++){ Node node = (Node) nodes.item(i); if(node instanceof Element){ Element element = (Element) node; String id = element.getAttribute(&quot;id&quot;); String className = element.getAttribute(&quot;class&quot;); //加载beanClass Class beanClass = null; try{ beanClass = Class.forName(className); }catch(ClassNotFoundException e){ e.printStackTrace(); return; } //创建bean Object bean = beanClass.newInstance(); //遍历&lt;property&gt;标签 NodeList propertyNodes = element.getElementsByTagName(&quot;property&quot;); for(int j = 0;j &lt; propertyNodes.getLength();j++){ Node properNode = (Node) propertyNodes.item(j); if(properNode instanceof Element){ Element propertyElement = (Element) properNode; String name = propertyElement.getAttribute(&quot;name&quot;); String value = propertyElement.getAttribute(&quot;value&quot;); //利用反射将bean相关字段访问权限设为可访问 Field declaredField = bean.getClass().getDeclaredField(name); String tString = declaredField.getType().getName(); declaredField.setAccessible(true); if(value != null &amp;&amp; value.length() &gt; 0){ if(tString.equals(&quot;java.lang.Integer&quot;)){ Integer temp = Integer.parseInt(value); declaredField.set(bean, temp); }else{ //将属性填充到相关字段中 declaredField.set(bean, value); } }else{ String ref = propertyElement.getAttribute(&quot;ref&quot;); if(ref == null || ref.length() == 0){ throw new IllegalArgumentException(&quot;ref config error&quot;); } //将引用填充到相关字段中 declaredField.set(bean, getBean(ref)); } //将bean注册到bean容器中 registerBean(id,bean); } } } } } private void registerBean(String id, Object bean) { beanMap.put(id, bean); } public Object getBean(String name) { Object bean = beanMap.get(name); if(bean == null){ throw new IllegalArgumentException(&quot;there is no bean with name &quot; + name); } return bean; } &ensp;&ensp;&ensp;&ensp;刚刚说了关键就是上面那个步骤，下面我将测试类代码也展示一下。 @Test public void getBean() throws Exception{ String location = MySimpleIOC.class.getClassLoader().getResource(&quot;springIoc.xml&quot;).getFile(); String temp = location.substring(1, location.length()); MySimpleIOC ioc = new MySimpleIOC(temp); StudentClass studentClass = (StudentClass) ioc.getBean(&quot;studentClass&quot;); System.out.println(studentClass + &quot;,&quot; +studentClass.getCode() +&quot;,&quot;+ studentClass.getMark()); Student student = (Student) ioc.getBean(&quot;student&quot;); System.out.println(student+&quot;,&quot; +student.getName()+&quot;,&quot;+student.getStudentClass().getCode()); }","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"软件工程","date":"2017-11-28T09:34:02.818Z","path":"2017/11/28/softProject/","text":"第一章1.软件：程序+数据+文档；2.软件的特性：（1）复杂性；（2）一致性；（3）退化性；（4）易变性；（5）移植性；（6）高成本性；3.软件危机：（1）软件规模大，复杂度增加，需求量增加，价格昂贵，供需矛盾。（2）软件开发质量差，研制过程难管理。（3）开发模式不能适应软件发展的需求。4.解决软件危机（避免二次开发）：（1）需求分析；（2）做好软件定义时期工作；（3）开发过程要有统一的，公认的方法论和规范指导；（4）必须在测试阶段充分做好检测工作。5.软件工程：核心思想：强调开发过程中需要应用工程化思想。软件开发中工程化的主要思想：软件项目管理。软件项目管理的作用：（1）提高质量，降低成本；（2）为软件的工程化开发提供保障。6.能力成熟度模型：CMM；软件开发范式（模型）：主要区别：模型不同；7.软件工程基本原理：（1）推迟实现原理；（2）逐步求精原理；（3）分解与抽象原理；（4）信息隐蔽原理；（5）质量保证原理；8.基本原则（确保软件产品质量与开发效率）：（1）分阶段的软件生存周期；（2）坚持进行阶段评审；（3）实行严格的产品控制；（4）采用现代程序设计技术；（5）明确责任；（6）开发小组的人员应少而精；（7）不断改进开发过程；9.结构化开发范式：技术包括：结构化分析、结构化设计、结构化编程和结构化测试。10.面向对象开发范式：优势：维护阶段；11.重型软件工程和轻型软件工程：一般大型项目使用重型软件工程，小型项目使用轻型软件工程。12.软件工程活动：沟通活动（包括确认合适的用户，非正式沟通和正式沟通）、计划活动（项目计划 项目跟踪管理）、建模活动（软件建模分为软件过程建模和软件本身建模，建模活动包括构建模型，描述模型）、实现活动（编码）、部署活动（建立系统运行的环境）、维护活动（在软件运行和维护阶段对软件产品进行必要的调整和修改）、管理活动、过程改进活动（过程定义和过程改进）。","tags":[{"name":"shu","slug":"shu","permalink":"http://yoursite.com/tags/shu/"}]},{"title":"第一个md文件","date":"2017-11-28T09:34:02.811Z","path":"2017/11/28/helloworld/","text":"This is a h112var a = 0377;alert(a);","tags":[]},{"title":"Hello World","date":"2017-11-28T09:34:02.806Z","path":"2017/11/28/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]